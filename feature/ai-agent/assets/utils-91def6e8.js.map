{"version":3,"file":"utils-91def6e8.js","sources":["../../packages/shared/src/utils/responses.ts","../../packages/shared/src/types/system-configuration.ts","../../packages/shared/src/utils/search-params.ts","../../packages/shared/src/utils/redirects.ts","../../packages/shared/src/utils/threads.ts","../../packages/shared/src/utils/security.ts","../../packages/shared/src/utils/requests.ts","../../node_modules/@tanstack/query-core/build/lib/subscribable.mjs","../../node_modules/@tanstack/query-core/build/lib/utils.mjs","../../node_modules/@tanstack/query-core/build/lib/notifyManager.mjs","../../node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs","../../node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs","../../node_modules/@tanstack/react-query/build/lib/utils.mjs"],"sourcesContent":["/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ErrorStatus } from './requests'\n\nexport class HttpError extends Error {\n  code: string\n  status: ErrorStatus\n\n  constructor(message: string, code: string, status: ErrorStatus) {\n    super(message)\n    this.name = 'HttpError'\n    this.code = code\n    this.status = status\n  }\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Key } from '../entities/keys'\n\nexport const IdentityProviderTypes = {\n  INTERNAL: 'internal',\n  EXTERNAL: 'external',\n} as const\n\nexport type IdentityProviderType = (typeof IdentityProviderTypes)[keyof typeof IdentityProviderTypes]\n\nexport type IdentityProviderDto = Readonly<{\n  id: Key\n  type: IdentityProviderType\n  displayName: string\n  loginStartEndpoint?: string\n  imageSvg?: string\n}>\n\nexport type InternalIdentityProvider = Omit<IdentityProviderDto, 'type'> & { type: typeof IdentityProviderTypes.INTERNAL }\nexport type ExternalIdentityProvider = Omit<IdentityProviderDto, 'type'> & { type: typeof IdentityProviderTypes.EXTERNAL }\n\nexport type SystemExtension = Readonly<{\n  name: string\n  baseUrl: string\n  pathPrefix: string\n}>\n\nexport type SystemConfigurationDto = Readonly<{\n  defaultWorkspaceId: string\n  authConfig: {\n    identityProviders: ReadonlyArray<IdentityProviderDto>\n    autoLogin?: boolean\n  }\n  extensions: Array<SystemExtension>\n}>\n\nexport type SystemConfiguration = SystemConfigurationDto\n\nexport function isInternalIdentityProvider(idp: IdentityProviderDto): idp is InternalIdentityProvider {\n  return idp.type === IdentityProviderTypes.INTERNAL\n}\n\nexport function isExternalIdentityProvider(idp: IdentityProviderDto): idp is ExternalIdentityProvider {\n  return idp.type === IdentityProviderTypes.EXTERNAL\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const PACKAGE_SEARCH_PARAM = 'package'\nexport const VERSION_SEARCH_PARAM = 'version'\nexport const OPERATION_SEARCH_PARAM = 'operation'\nexport const GROUP_SEARCH_PARAM = 'group'\nexport const WORKSPACE_SEARCH_PARAM = 'workspace'\nexport const TAG_SEARCH_PARAM = 'tag'\nexport const FILTERS_SEARCH_PARAM = 'filters'\nexport const EXPAND_NAVIGATION_MENU_SEARCH_PARAM = 'expandNavigationMenu'\nexport const FILE_VIEW_MODE_PARAM_KEY = 'fileViewMode'\nexport const REF_SEARCH_PARAM = 'ref'\nexport const DOCUMENT_SEARCH_PARAM = 'document'\nexport const MODE_SEARCH_PARAM = 'mode'\nexport const PLAYGROUND_SIDEBAR_VIEW_MODE_SEARCH_PARAM = 'sidebar'\nexport const API_TYPE_SEARCH_PARAM = 'apiType'\nexport const BRANCH_SEARCH_PARAM = 'branch'\nexport const VIEW_SEARCH_PARAM = 'view'\nexport const SEARCH_TEXT_PARAM_KEY = 'text'\nexport const OPERATIONS_VIEW_MODE_PARAM = 'viewMode'\n\nexport interface SearchParam {\n  value: unknown\n  toStringValue?: (value: object | string | number) => string\n}\n\nexport function optionalSearchParams(\n  params: Record<string, {\n    value: unknown\n    toStringValue?: (value: object | string | number) => string\n  }>,\n): URLSearchParams {\n  const searchParams = new URLSearchParams()\n\n  Object.entries(params).forEach(([key, { value, toStringValue }]) => {\n    if (Array.isArray(value)) {\n      const [first] = value\n      if (!first) {\n        return\n      }\n    }\n\n    if (value || value === 0) {\n      searchParams.set(key, toStringValue?.(value) ?? `${value}`)\n    }\n  })\n\n  return searchParams\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { PathMatch } from 'react-router'\nimport { matchPath } from 'react-router-dom'\nimport { SEARCH_PARAM_NO_AUTO_LOGIN, SEARCH_PARAM_REDIRECT_URI } from './constants'\nimport type { FetchRedirectDetails } from './requests'\nimport { API_BASE_PATH_PATTERN, FETCH_REDIRECT_TYPE_PACKAGE } from './requests'\nimport { optionalSearchParams } from './search-params'\n\nexport function redirectToGitlab(): void {\n  redirectTo('/login/gitlab')\n}\n\nexport function redirectToLogin(): void {\n  redirectTo('/login', optionalSearchParams({\n    [SEARCH_PARAM_NO_AUTO_LOGIN]: { value: true },\n    redirectUri: { value: location.href },\n  }))\n}\n\nexport function redirectTo(path: string, searchParams: URLSearchParams = new URLSearchParams()): void {\n  const redirectUri = searchParams.get('redirectUri') ?? location.href\n  searchParams.set('redirectUri', redirectUri)\n\n  let url = location.origin\n  if (path.includes('?')) {\n    url = `${url}${path}&${searchParams}`\n  } else {\n    url = `${url}${path}?${searchParams}`\n  }\n\n  (() => {\n    window.stop()\n    location.replace(url)\n  })()\n}\n\ntype PackagePathPattern = `/${string}/:packageId${'' | `/${string}`}`\n\n// Path Patterns should not include API_BASE_PATH\nexport function getPackageRedirectDetails<P extends PackagePathPattern>(\n  response: Response,\n  pathPattern: P,\n): FetchRedirectDetails | null {\n  const redirectedUrl = new URL(response.url)\n  const match = matchPath(`${API_BASE_PATH_PATTERN}${pathPattern}`, redirectedUrl.pathname) as PathMatch<'packageId'> | null\n  return match && match.params.packageId\n    ? {\n      redirectType: FETCH_REDIRECT_TYPE_PACKAGE,\n      id: match.params.packageId,\n    }\n    : null\n}\n\nexport function getRedirectUri(): string {\n  const url = new URL(location.href)\n  const redirectUri = url.searchParams.get(SEARCH_PARAM_REDIRECT_URI)\n  if (redirectUri) {\n    return redirectUri\n  }\n  if (location.pathname === '/login') {\n    return location.origin\n  }\n  return location.href\n}\n","export async function stopThread(message: string = 'Thread is stopped'): Promise<void> {\n  await pauseThread(0, message)\n}\n\nexport async function pauseThread(timeoutMs: number = 0, message: string = 'Thread is paused'): Promise<void> {\n  await new Promise(resolve => {\n    console.log(message)\n    if (timeoutMs > 0) {\n      setTimeout(() => {\n        resolve(undefined)\n      }, timeoutMs)\n    }\n  })\n}\n","import type { QueryObserverResult, RefetchOptions, RefetchQueryFilters, UseMutateFunction } from '@tanstack/react-query'\nimport type { IdentityProviderDto, SystemConfigurationDto } from '../types/system-configuration'\nimport { isInternalIdentityProvider } from '../types/system-configuration'\nimport {\n  SEARCH_PARAM_NO_AUTO_LOGIN,\n  SESSION_STORAGE_KEY_LAST_IDENTITY_PROVIDER_ID,\n  SESSION_STORAGE_KEY_SYSTEM_CONFIGURATION,\n} from './constants'\nimport { getRedirectUri, redirectTo, redirectToLogin } from './redirects'\nimport { optionalSearchParams } from './search-params'\nimport { stopThread } from './threads'\n\n// TODO 16.05.25 // Temporarily copy-pasted from ./requests.ts\n// Get rid of copy-pasting these constants\nconst API_V3 = '/api/v3'\n\nexport const TokenRefreshResults = {\n  NO_PROVIDER: 'no-provider',\n  NO_ENDPOINT: 'no-endpoint',\n  TOKEN_REFRESHED: 'token-refreshed',\n  UNKNOWN: 'unknown',\n} as const\nexport type TokenRefreshResult = (typeof TokenRefreshResults)[keyof typeof TokenRefreshResults]\n\nexport function isTokenRefreshed(maybeTokenRefreshResult: unknown): maybeTokenRefreshResult is typeof TokenRefreshResults.TOKEN_REFRESHED {\n  return maybeTokenRefreshResult === TokenRefreshResults.TOKEN_REFRESHED\n}\n\nexport class WorkerUnauthorizedError extends Error {\n  readonly responseStatus: number = 401\n\n  constructor() {\n    super('HTTP 401 Unauthorized')\n    this.name = 'WorkerUnauthorizedError'\n  }\n}\n\nexport function isInWebWorker(self: unknown): self is WorkerGlobalScope {\n  return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n}\n\nexport async function handleAuthentication(responseStatus: number): Promise<TokenRefreshResult | undefined> {\n  const searchParams = new URLSearchParams(location.search)\n  // noAutoLogin = true in 2 cases:\n  // 1. user manually logged out just now\n  // 2. user logged in just now and automatically redirect to login page\n  const allowedAutoLogin = !searchParams.get(SEARCH_PARAM_NO_AUTO_LOGIN)\n\n  let tokenRefreshResult: TokenRefreshResult | undefined\n\n  if (responseStatus === 401 && allowedAutoLogin) {\n    let lastProviderId: string | null | undefined\n    let systemConfigurationDto: SystemConfigurationDto | undefined\n    if (isInWebWorker(self)) {\n      ({\n        systemConfigurationDto,\n        lastIdentityProviderId: lastProviderId,\n      } = self)\n    }\n\n    // must be always present,\n    // because protected API is not fetched until system configuration is loaded\n    systemConfigurationDto = systemConfigurationDto || JSON.parse(sessionStorage.getItem(SESSION_STORAGE_KEY_SYSTEM_CONFIGURATION)!) as SystemConfigurationDto\n\n    const { authConfig } = systemConfigurationDto\n\n    // trying to refresh token by auto-login provider\n    const { autoLogin } = authConfig\n    if (autoLogin) {\n      const [autoLoginProvider] = authConfig.identityProviders\n      tokenRefreshResult = await handleUnauthorizedByProvider(autoLoginProvider)\n      if (isTokenRefreshed(tokenRefreshResult)) {\n        return tokenRefreshResult\n      }\n    } else {\n      // trying to refresh token by last used provider\n      lastProviderId = lastProviderId || localStorage.getItem(SESSION_STORAGE_KEY_LAST_IDENTITY_PROVIDER_ID)\n      const lastProvider = lastProviderId\n        ? authConfig.identityProviders.find(idp => idp.id === lastProviderId)\n        : undefined\n\n      tokenRefreshResult = await handleUnauthorizedByProvider(lastProvider)\n      if (isTokenRefreshed(tokenRefreshResult)) {\n        return tokenRefreshResult\n      }\n    }\n\n    // the first login in clear browser\n    if (tokenRefreshResult === TokenRefreshResults.NO_PROVIDER) {\n      redirectToLogin()\n    }\n  }\n\n  return tokenRefreshResult\n}\n\nasync function handleUnauthorizedByProvider(identityProvider: IdentityProviderDto | undefined): Promise<TokenRefreshResult> {\n  if (!identityProvider) {\n    return TokenRefreshResults.NO_PROVIDER\n  }\n\n  let requestEndpoint = ''\n  if (isInternalIdentityProvider(identityProvider)) {\n    // Parameter \"redirectUri\" is used to redirect when the user is not authenticated and token can't be refreshed\n    // In that case we should redirect to the login page with its own \"redirectUri\"\n    // which will be used after logging in via internal identity provider to redirect to the original page.\n    const searchParamsLoginPage = optionalSearchParams({ noAutoLogin: { value: true }, redirectUri: { value: getRedirectUri() } })\n    const searchParamsAuthLocalRefresh = optionalSearchParams({ redirectUri: { value: `${location.origin}/login?${searchParamsLoginPage}` } })\n    requestEndpoint = `${API_V3}/auth/local/refresh?${searchParamsAuthLocalRefresh}`\n  } else if (identityProvider.loginStartEndpoint) {\n    // In case of external identity provider, we don't have control over the redirections and we provide\n    // just \"redirectUri\" with value of the current page OR main page (if current page is login page),\n    // because internal redirections will be managed by the backend and the provider.\n    const searchParamsAuthWithStartEndpoint = optionalSearchParams({ redirectUri: { value: getRedirectUri() } })\n    requestEndpoint = `${identityProvider.loginStartEndpoint}?${searchParamsAuthWithStartEndpoint}`\n  } else {\n    return TokenRefreshResults.NO_ENDPOINT\n  }\n  const response = await fetch(\n    requestEndpoint,\n    {\n      method: 'GET',\n      redirect: 'manual',\n    },\n  )\n  if (response.ok) {\n    return TokenRefreshResults.TOKEN_REFRESHED\n  }\n  if (response.type === 'opaqueredirect') {\n    const url = response.url.replace(location.origin, '')\n    redirectTo(url)\n    /**\n     * TL;DR: Redirections are asyncronous global tasks\n     * Details:\n     * - https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate\n     * - Some part of navigation algorithm is run synchronously until the point 8 from specs.\n     * - Since this moment, if surrounding (!) code is running, it will be finished first.\n     * - Surrounding code includes both synchronous and asynchronous code.\n     * - Continuing navigation will be planned as a global task.\n     * - After surrounding code is finished, navigation will be executed,\n     *   BUT:\n     *   If any microtask will never be resolved, navigation will be executed anyway\n     *   after the last reached surrounding code is executed.\n     * - So, as the result, we can stop thread to wait for the redirection with infinite promise.\n     */\n    await stopThread('Waiting for redirection...')\n  }\n  console.error('Can\\'t refresh token. Response:', response)\n  return TokenRefreshResults.UNKNOWN\n}\n\nfunction isWorkerUnauthorizedError(error: unknown): error is WorkerUnauthorizedError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'name' in error &&\n    error.name === 'WorkerUnauthorizedError' &&\n    'responseStatus' in error &&\n    typeof error.responseStatus === 'number'\n  )\n}\n\ntype MutationUnauthorizedHandler<TError, TVariables, TContext>\n  = (error: TError, variables: TVariables, context: TContext) => Promise<TokenRefreshResult | undefined>\n\nexport function onMutationUnauthorized<TData = unknown, TError extends Error = Error, TVariables = void, TContext = unknown>(\n  mutate: UseMutateFunction<TData, TError, TVariables, TContext>,\n): MutationUnauthorizedHandler<TError, TVariables, TContext> {\n\n  return async (error, variables): Promise<TokenRefreshResult | undefined> => {\n    if (isWorkerUnauthorizedError(error)) {\n      const tokenRefreshResult = await handleAuthentication(error.responseStatus)\n      if (tokenRefreshResult === TokenRefreshResults.TOKEN_REFRESHED) {\n        mutate(variables)\n      }\n      return tokenRefreshResult\n    }\n  }\n}\n\ntype QueryUnauthorizedHandler<TError> = (error: TError) => Promise<TokenRefreshResult | undefined>\n\nexport function onQueryUnauthorized<TData = unknown, TError extends Error = Error>(\n  refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<TData, TError>>,\n): QueryUnauthorizedHandler<TError> {\n\n  return async (error): Promise<TokenRefreshResult | undefined> => {\n    if (isWorkerUnauthorizedError(error)) {\n      const tokenRefreshResult = await handleAuthentication(error.responseStatus)\n      if (tokenRefreshResult === TokenRefreshResults.TOKEN_REFRESHED) {\n        refetch()\n      }\n      return tokenRefreshResult\n    }\n  }\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fileDownload from 'js-file-download'\nimport type { ErrorMessage } from './packages-builder'\nimport { HttpError } from './responses'\nimport { handleAuthentication, isTokenRefreshed } from './security'\nimport type { Key } from './types'\n\nexport const API_V1 = '/api/v1'\nexport const API_V2 = '/api/v2'\nexport const API_V3 = '/api/v3'\nexport const API_V4 = '/api/v4'\n\nexport const API_BASE_PATH_PATTERN = '/api/:apiVersion'\n\n// TODO 06.11.25 // REMOVE IT!\n// export const STUB_API_V1 = '/stub/api/v1'\nexport const STUB_API_V1 = '/api-linter/api/v1'\n// ---\n\nexport const STATUS_REFETCH_INTERVAL = 3 * 1000 // three seconds\nexport const DEFAULT_REFETCH_INTERVAL = 5 * (60 * 1000) // five minutes\n\nexport type CustomErrorHandler = (response: Response) => void\nexport type CustomRedirectHandler = (response: Response) => FetchRedirectDetails | null\n\nexport type RequestJsonExtraOptions = {\n  basePath?: string\n  customErrorHandler?: CustomErrorHandler\n  customRedirectHandler?: CustomRedirectHandler\n  ignoreNotFound?: boolean\n}\n\nexport async function requestJson<T extends object | null>(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n  options: RequestJsonExtraOptions = {},\n  signal?: AbortSignal,\n): Promise<T> {\n  const { basePath = '', customErrorHandler, customRedirectHandler, ignoreNotFound = false } = options\n\n  const response = await fetch(`${basePath}${input}`, {\n    ...init,\n    signal: signal,\n    credentials: 'include',\n  })\n\n  if (!response.ok) {\n    const tokenRefreshResult = await handleAuthentication(response.status)\n    if (isTokenRefreshed(tokenRefreshResult)) {\n      return requestJson(input, init, options, signal)\n    }\n\n    await handleFetchError(response, { 401: true, 404: ignoreNotFound }, customErrorHandler)\n    return null as T\n  }\n\n  await handleFetchRedirect(response, customRedirectHandler)\n\n  return await response.json() as T\n}\n\nexport type RequestUnknownExtraOptions = {\n  basePath?: string\n  customErrorHandler?: CustomErrorHandler\n  customRedirectHandler?: CustomRedirectHandler\n  ignoreNotFound?: boolean\n  mediaTypes?: string[]\n}\n\nexport async function requestUnknown<T extends Record<PropertyKey, unknown> | null>(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n  options: RequestUnknownExtraOptions = {},\n  signal?: AbortSignal,\n): Promise<T> {\n  const {\n    basePath = '',\n    customErrorHandler,\n    customRedirectHandler,\n    ignoreNotFound = false,\n    mediaTypes = [],\n  } = options\n\n  const response = await fetch(`${basePath}${input}`, {\n    headers: {\n      ...mediaTypes.length ? { 'Accept': mediaTypes.join(', ') } : {},\n    },\n    ...init,\n    signal: signal,\n    credentials: 'include',\n  })\n\n  if (!response.ok) {\n    const tokenRefreshResult = await handleAuthentication(response.status)\n    if (isTokenRefreshed(tokenRefreshResult)) {\n      return requestJson(input, init, options, signal)\n    }\n\n    await handleFetchError(response, { 401: true, 404: ignoreNotFound }, customErrorHandler)\n    return null as T\n  }\n\n  await handleFetchRedirect(response, customRedirectHandler)\n\n  // Handle unknown response\n  const contentType = response.headers.get('content-type')\n  if (contentType?.includes('application/json')) {\n    return await response.json()\n  }\n  if (contentType?.includes('application/octet-stream')) {\n    const getFilename = (): string => response.headers\n      .get('content-disposition')!\n      .split('filename=')[1]\n      .split(';')[0]\n    const data = await response.blob()\n    fileDownload(data, getFilename())\n    return null as T\n  }\n  return null as T\n}\n\nexport type RequestTextExtraOptions = {\n  basePath?: string\n  customErrorHandler?: CustomErrorHandler\n  customRedirectHandler?: CustomRedirectHandler\n}\n\nexport async function requestText(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n  options: RequestTextExtraOptions = {},\n): Promise<string> {\n  const { basePath = '', customErrorHandler, customRedirectHandler } = options\n\n  const response = await fetch(`${basePath ?? ''}${input}`, {\n    ...init,\n    credentials: 'include',\n  })\n\n  if (!response.ok) {\n    const tokenRefreshResult = await handleAuthentication(response.status)\n    if (isTokenRefreshed(tokenRefreshResult)) {\n      return requestText(input, init, options)\n    }\n\n    await handleFetchError(response, { 401: true }, customErrorHandler)\n    return ''\n  }\n\n  await handleFetchRedirect(response, customRedirectHandler)\n  return await response.text()\n}\n\nexport type RequestBlobExtraOptions = {\n  basePath?: string\n  customErrorHandler?: CustomErrorHandler\n  customRedirectHandler?: CustomRedirectHandler\n}\n\nexport async function requestBlob(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n  options: RequestBlobExtraOptions = {},\n): Promise<Response> {\n  const { basePath = '', customErrorHandler, customRedirectHandler } = options\n\n  const response = await fetch(`${basePath ?? ''}${input}`, {\n    ...init,\n    credentials: 'include',\n  })\n\n  if (!response.ok) {\n    const tokenRefreshResult = await handleAuthentication(response.status)\n    if (isTokenRefreshed(tokenRefreshResult)) {\n      return requestBlob(input, init, options)\n    }\n\n    if (customErrorHandler) {\n      customErrorHandler(response)\n    } else {\n      await handleError(response)\n    }\n  }\n\n  await handleFetchRedirect(response, customRedirectHandler)\n  return response\n}\n\nexport type RequestVoidExtraOptions = {\n  basePath?: string\n  ignoreNotFound?: boolean\n  customErrorHandler?: CustomErrorHandler\n  customRedirectHandler?: CustomRedirectHandler\n}\n\nexport async function requestVoid(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n  options: RequestVoidExtraOptions = {},\n): Promise<void> {\n  const { basePath = '', ignoreNotFound = false, customErrorHandler, customRedirectHandler } = options\n\n  const response = await fetch(`${basePath}${input}`, {\n    ...init,\n    credentials: 'include',\n  })\n\n  if (!response.ok) {\n    const tokenRefreshResult = await handleAuthentication(response.status)\n    if (isTokenRefreshed(tokenRefreshResult)) {\n      return requestVoid(input, init, options)\n    }\n\n    await handleFetchError(response, { 401: true, 404: ignoreNotFound }, customErrorHandler)\n  }\n\n  await handleFetchRedirect(response, customRedirectHandler)\n  return\n}\n\nasync function handleFetchError(\n  response: Response,\n  ignoredStatuses: Record<number, boolean>,\n  customErrorHandler?: CustomErrorHandler,\n): Promise<void> {\n  if (ignoredStatuses[response.status]) {\n    return Promise.reject()\n  }\n\n  if (customErrorHandler) {\n    customErrorHandler(response)\n  } else {\n    await handleCustomError(response)\n  }\n}\n\nasync function handleFetchRedirect(response: Response, customRedirectHandler?: CustomRedirectHandler): Promise<void> {\n  if (response.redirected && customRedirectHandler) {\n    const redirectDetails = customRedirectHandler(response)\n    if (redirectDetails) {\n      await handleCustomRedirect(redirectDetails)\n    } else {\n      await handleCustomError(response)\n    }\n  }\n}\n\nasync function handleCustomError(response: Response): Promise<void> {\n  const [message, code, status] = await getResponseError(response)\n  const detail = { title: `Error ${response.status}`, message: message, code: code, status: status }\n  dispatchEvent(new CustomEvent<FetchErrorDetails>(FETCH_ERROR_EVENT, {\n    detail: detail,\n    bubbles: true,\n    composed: true,\n    cancelable: false,\n  }))\n  throw new HttpError(message, code, status)\n}\n\nasync function handleCustomRedirect(details: FetchRedirectDetails): Promise<void> {\n  dispatchEvent(new CustomEvent<FetchRedirectDetails>(FETCH_REDIRECT_EVENT, {\n    detail: details,\n    bubbles: true,\n    composed: true,\n    cancelable: false,\n  }))\n  window.stop()\n}\n\nexport type ErrorCode = string\nexport type ErrorStatus = number | null\n\nexport type ResponseError = Readonly<{\n  code: ErrorCode\n  message: ErrorMessage\n  params?: { [key: string]: string }\n  status: ErrorStatus\n}>\n\nexport async function getResponseError(response: Response): Promise<[ErrorMessage, ErrorCode, ErrorStatus]> {\n  const errorObject = await response.json() as ResponseError | null\n  const errorMessage = errorObject?.message ?? 'Something went wrong'\n  const errorCode = errorObject?.code ?? ''\n  const errorStatus = errorObject?.status ?? null\n  if (!errorObject?.params) {\n    return [errorMessage, errorCode, errorStatus]\n  }\n  return [\n    Object.entries(errorObject.params).reduce((message, [key, value]) => {\n      return message.replace(`$${key}`, value)\n    }, errorMessage),\n    errorCode,\n    errorStatus,\n  ]\n}\n\nexport class NotFoundError extends Error { }\n\nasync function handleError(response: Response): Promise<void> {\n  const [message] = await getResponseError(response)\n  if (response.status === 404) {\n    throw new NotFoundError(message)\n  }\n  throw new Error(message)\n}\n\nexport const FETCH_ERROR_EVENT = 'fetch-error'\nexport const FETCH_REDIRECT_EVENT = 'fetch-redirect'\n\nexport type FetchErrorDetails = {\n  title: string\n  message: ErrorMessage\n  code: ErrorCode\n  status: ErrorStatus\n}\n\nexport const FETCH_REDIRECT_TYPE_PACKAGE = 'package-redirect'\nexport type FetchRedirectType = typeof FETCH_REDIRECT_TYPE_PACKAGE\n\nexport type FetchRedirectDetails = {\n  redirectType: FetchRedirectType\n  id: Key\n}\n\nexport const ERROR_CODE_OPERATION_NOT_FOUND = '2301'\nexport const ERROR_CODE_IDP_URL_NOT_FOUND = '2902'\n","class Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { useSyncExternalStore as useSyncExternalStore$1 } from 'use-sync-external-store/shim/index.js';\n\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nconst useSyncExternalStore = useSyncExternalStore$1;\n\nexport { useSyncExternalStore };\n//# sourceMappingURL=useSyncExternalStore.mjs.map\n","import * as React from 'react';\n\nconst defaultContext = /*#__PURE__*/React.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(context, contextSharing) {\n  if (context) {\n    return context;\n  }\n\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nconst useQueryClient = ({\n  context\n} = {}) => {\n  const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nconst QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client.getLogger().error(\"The contextSharing option has been deprecated and will be removed in the next major version\");\n  }\n\n  const Context = getQueryClientContext(context, contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: !context && contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};\n\nexport { QueryClientProvider, defaultContext, useQueryClient };\n//# sourceMappingURL=QueryClientProvider.mjs.map\n","function shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nexport { shouldThrowError };\n//# sourceMappingURL=utils.mjs.map\n"],"names":["HttpError","message","code","status","__publicField","IdentityProviderTypes","isInternalIdentityProvider","idp","PACKAGE_SEARCH_PARAM","optionalSearchParams","params","searchParams","key","value","toStringValue","first","redirectToLogin","redirectTo","SEARCH_PARAM_NO_AUTO_LOGIN","path","redirectUri","url","getPackageRedirectDetails","response","pathPattern","redirectedUrl","match","matchPath","API_BASE_PATH_PATTERN","FETCH_REDIRECT_TYPE_PACKAGE","getRedirectUri","SEARCH_PARAM_REDIRECT_URI","stopThread","pauseThread","timeoutMs","resolve","API_V3","TokenRefreshResults","isTokenRefreshed","maybeTokenRefreshResult","isInWebWorker","self","handleAuthentication","responseStatus","allowedAutoLogin","tokenRefreshResult","lastProviderId","systemConfigurationDto","SESSION_STORAGE_KEY_SYSTEM_CONFIGURATION","authConfig","autoLogin","autoLoginProvider","handleUnauthorizedByProvider","SESSION_STORAGE_KEY_LAST_IDENTITY_PROVIDER_ID","lastProvider","identityProvider","requestEndpoint","searchParamsLoginPage","searchParamsAuthLocalRefresh","searchParamsAuthWithStartEndpoint","API_V1","STUB_API_V1","DEFAULT_REFETCH_INTERVAL","requestJson","input","init","options","signal","basePath","customErrorHandler","customRedirectHandler","ignoreNotFound","handleFetchError","handleFetchRedirect","ignoredStatuses","handleCustomError","redirectDetails","handleCustomRedirect","getResponseError","detail","FETCH_ERROR_EVENT","details","FETCH_REDIRECT_EVENT","errorObject","errorMessage","errorCode","errorStatus","Subscribable","listener","x","isServer","noop","isValidTimeout","timeUntilStale","updatedAt","staleTime","parseQueryArgs","arg1","arg2","arg3","isQueryKey","parseMutationArgs","replaceEqualDeep","a","b","array","isPlainArray","isPlainObject","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","o","hasObjectPrototype","ctor","prot","sleep","timeout","scheduleMicrotask","callback","replaceData","prevData","data","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","result","flush","schedule","batchCalls","args","originalQueue","fn","notifyManager","useSyncExternalStore","useSyncExternalStore$1","defaultContext","React.createContext","QueryClientSharingContext","getQueryClientContext","context","contextSharing","useQueryClient","queryClient","React.useContext","shouldThrowError","_useErrorBoundary"],"mappings":"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","x_google_ignoreList":[7,8,9,10,11,12]}