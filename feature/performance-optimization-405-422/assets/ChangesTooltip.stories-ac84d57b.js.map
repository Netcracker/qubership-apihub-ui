{"version":3,"file":"ChangesTooltip.stories-ac84d57b.js","sources":["../../node_modules/@netcracker/qubership-apihub-api-diff/node_modules/fast-equals/dist/fast-equals.esm.js","../../node_modules/@netcracker/qubership-apihub-api-diff/dist/index.es.js","../../packages/shared/src/entities/change-severities.ts","../../packages/shared/src/components/MarkerTooltip.tsx","../../packages/shared/src/components/ChangesTooltip.tsx"],"sourcesContent":["/**\r\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n * use inside the built comparator.\r\n */\r\nfunction createDefaultIsNestedEqual(comparator) {\r\n    return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {\r\n        return comparator(a, b, meta);\r\n    };\r\n}\r\n/**\r\n * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\r\n * for circular references to be safely included in the comparison without creating\r\n * stack overflows.\r\n */\r\nfunction createIsCircular(areItemsEqual) {\r\n    return function isCircular(a, b, isEqual, cache) {\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return areItemsEqual(a, b, isEqual, cache);\r\n        }\r\n        var cachedA = cache.get(a);\r\n        var cachedB = cache.get(b);\r\n        if (cachedA && cachedB) {\r\n            return cachedA === b && cachedB === a;\r\n        }\r\n        cache.set(a, b);\r\n        cache.set(b, a);\r\n        var result = areItemsEqual(a, b, isEqual, cache);\r\n        cache.delete(a);\r\n        cache.delete(b);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Targeted shallow merge of two objects.\r\n *\r\n * @NOTE\r\n * This exists as a tinier compiled version of the `__assign` helper that\r\n * `tsc` injects in case of `Object.assign` not being present.\r\n */\r\nfunction merge(a, b) {\r\n    var merged = {};\r\n    for (var key in a) {\r\n        merged[key] = a[key];\r\n    }\r\n    for (var key in b) {\r\n        merged[key] = b[key];\r\n    }\r\n    return merged;\r\n}\r\n/**\r\n * Whether the value is a plain object.\r\n *\r\n * @NOTE\r\n * This is a same-realm compariosn only.\r\n */\r\nfunction isPlainObject(value) {\r\n    return value.constructor === Object || value.constructor == null;\r\n}\r\n/**\r\n * When the value is `Promise`-like, aka \"then-able\".\r\n */\r\nfunction isPromiseLike(value) {\r\n    return typeof value.then === 'function';\r\n}\r\n/**\r\n * Whether the values passed are strictly equal or both NaN.\r\n */\r\nfunction sameValueZeroEqual(a, b) {\r\n    return a === b || (a !== a && b !== b);\r\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\r\nvar BOOLEAN_TAG = '[object Boolean]';\r\nvar DATE_TAG = '[object Date]';\r\nvar REG_EXP_TAG = '[object RegExp]';\r\nvar MAP_TAG = '[object Map]';\r\nvar NUMBER_TAG = '[object Number]';\r\nvar OBJECT_TAG = '[object Object]';\r\nvar SET_TAG = '[object Set]';\r\nvar STRING_TAG = '[object String]';\r\nvar toString = Object.prototype.toString;\r\nfunction createComparator(_a) {\r\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;\r\n    var isEqual = createIsNestedEqual(comparator);\r\n    /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     */\r\n    function comparator(a, b, meta) {\r\n        // If the items are strictly equal, no need to do a value comparison.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // If the items are not non-nullish objects, then the only possibility\r\n        // of them being equal but not strictly is if they are both `NaN`. Since\r\n        // `NaN` is uniquely not equal to itself, we can use self-comparison of\r\n        // both objects, which is faster than `isNaN()`.\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return a !== a && b !== b;\r\n        }\r\n        // Checks are listed in order of commonality of use-case:\r\n        //   1. Common complex object types (plain object, array)\r\n        //   2. Common data values (date, regexp)\r\n        //   3. Less-common complex object types (map, set)\r\n        //   4. Less-common data values (promise, primitive wrappers)\r\n        // Inherently this is both subjective and assumptive, however\r\n        // when reviewing comparable libraries in the wild this order\r\n        // appears to be generally consistent.\r\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n        // comparisons are rare, and will be handled in the ultimate fallback, so\r\n        // we can avoid the `toString.call()` cost unless necessary.\r\n        if (isPlainObject(a) && isPlainObject(b)) {\r\n            return areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // `isArray()` works on subclasses and is cross-realm, so we can again avoid\r\n        // the `toString.call()` cost unless necessary by just checking if either\r\n        // and then both are arrays.\r\n        var aArray = Array.isArray(a);\r\n        var bArray = Array.isArray(b);\r\n        if (aArray || bArray) {\r\n            return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\r\n        }\r\n        // Since this is a custom object, use the classic `toString.call()` to get its\r\n        // type. This is reasonably performant in modern environments like v8 and\r\n        // SpiderMonkey, and allows for cross-realm comparison when other checks like\r\n        // `instanceof` do not.\r\n        var aTag = toString.call(a);\r\n        if (aTag !== toString.call(b)) {\r\n            return false;\r\n        }\r\n        if (aTag === DATE_TAG) {\r\n            // `getTime()` showed better results compared to alternatives like `valueOf()`\r\n            // or the unary `+` operator.\r\n            return areDatesEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === REG_EXP_TAG) {\r\n            return areRegExpsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === MAP_TAG) {\r\n            return areMapsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === SET_TAG) {\r\n            return areSetsEqual(a, b, isEqual, meta);\r\n        }\r\n        // If a simple object tag, then we can prioritize a simple object comparison because\r\n        // it is likely a custom class. If an arguments tag, it should be treated as a standard\r\n        // object.\r\n        if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\r\n            // The exception for value comparison is `Promise`-like contracts. These should be\r\n            // treated the same as standard `Promise` objects, which means strict equality.\r\n            return isPromiseLike(a) || isPromiseLike(b)\r\n                ? false\r\n                : areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n        // types.\r\n        if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\r\n            return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n        }\r\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n        //     comparison that can be made.\r\n        //   - For types that can be introspected, but rarely have requirements to be compared\r\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n        //     use-cases (may be included in a future release, if requested enough).\r\n        //   - For types that can be introspected but do not have an objective definition of what\r\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n        // In all cases, these decisions should be reevaluated based on changes to the language and\r\n        // common development practices.\r\n        return false;\r\n    }\r\n    return comparator;\r\n}\n\n/**\r\n * Whether the arrays are equal in value.\r\n */\r\nfunction areArraysEqual(a, b, isEqual, meta) {\r\n    var index = a.length;\r\n    if (b.length !== index) {\r\n        return false;\r\n    }\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the arrays are equal in value, including circular references.\r\n */\r\nvar areArraysEqualCircular = createIsCircular(areArraysEqual);\n\n/**\r\n * Whether the dates passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides.\r\n */\r\nfunction areDatesEqual(a, b) {\r\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n}\n\n/**\r\n * Whether the `Map`s are equal in value.\r\n */\r\nfunction areMapsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    var indexA = 0;\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndexB = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndexB] &&\r\n                (hasMatch =\r\n                    isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\r\n                        isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndexB] = true;\r\n            }\r\n            matchIndexB++;\r\n        });\r\n        indexA++;\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Map`s are equal in value, including circular references.\r\n */\r\nvar areMapsEqualCircular = createIsCircular(areMapsEqual);\n\nvar OWNER = '_owner';\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n/**\r\n * Whether the objects are equal in value.\r\n */\r\nfunction areObjectsEqual(a, b, isEqual, meta) {\r\n    var keysA = Object.keys(a);\r\n    var index = keysA.length;\r\n    if (Object.keys(b).length !== index) {\r\n        return false;\r\n    }\r\n    var key;\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        key = keysA[index];\r\n        if (key === OWNER) {\r\n            var reactElementA = !!a.$$typeof;\r\n            var reactElementB = !!b.$$typeof;\r\n            if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!hasOwnProperty.call(b, key) ||\r\n            !isEqual(a[key], b[key], key, key, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the objects are equal in value, including circular references.\r\n */\r\nvar areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n\n/**\r\n * Whether the regexps passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides. An example of this would be supporting a\r\n * pre-ES2015 environment where the `flags` property is not available.\r\n */\r\nfunction areRegExpsEqual(a, b) {\r\n    return a.source === b.source && a.flags === b.flags;\r\n}\n\n/**\r\n * Whether the `Set`s are equal in value.\r\n */\r\nfunction areSetsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndex = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndex] &&\r\n                (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndex] = true;\r\n            }\r\n            matchIndex++;\r\n        });\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Set`s are equal in value, including circular references.\r\n */\r\nvar areSetsEqualCircular = createIsCircular(areSetsEqual);\n\nvar DEFAULT_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqual,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqual,\r\n    areObjectsEqual: areObjectsEqual,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqual,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar DEFAULT_CIRCULAR_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqualCircular,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqualCircular,\r\n    areObjectsEqual: areObjectsEqualCircular,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqualCircular,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar isDeepEqual = createComparator(DEFAULT_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value.\r\n */\r\nfunction deepEqual(a, b) {\r\n    return isDeepEqual(a, b, undefined);\r\n}\r\nvar isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function () { return sameValueZeroEqual; } }));\r\n/**\r\n * Whether the items passed are shallowly-equal in value.\r\n */\r\nfunction shallowEqual(a, b) {\r\n    return isShallowEqual(a, b, undefined);\r\n}\r\nvar isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value, including circular references.\r\n */\r\nfunction circularDeepEqual(a, b) {\r\n    return isCircularDeepEqual(a, b, new WeakMap());\r\n}\r\nvar isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {\r\n    createIsNestedEqual: function () { return sameValueZeroEqual; },\r\n}));\r\n/**\r\n * Whether the items passed are shallowly-equal in value, including circular references.\r\n */\r\nfunction circularShallowEqual(a, b) {\r\n    return isCircularShallowEqual(a, b, new WeakMap());\r\n}\r\n/**\r\n * Create a custom equality comparison method.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `RegExp.prototype.flags` out of the box.\r\n */\r\nfunction createCustomEqual(getComparatorOptions) {\r\n    return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));\r\n}\r\n/**\r\n * Create a custom equality comparison method that handles circular references. This is very\r\n * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\r\n * populated with a `WeakMap`-like contract.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `WeakMap` out of the box.\r\n */\r\nfunction createCustomCircularEqual(getComparatorOptions) {\r\n    var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));\r\n    return (function (a, b, meta) {\r\n        if (meta === void 0) { meta = new WeakMap(); }\r\n        return comparator(a, b, meta);\r\n    });\r\n}\n\nexport { circularDeepEqual, circularShallowEqual, createCustomCircularEqual, createCustomEqual, deepEqual, sameValueZeroEqual, shallowEqual };\n//# sourceMappingURL=fast-equals.esm.js.map\n","import { anyArrayKeys, syncCrawl, getNodeRules, syncClone, isArray as isArray$1, isObject as isObject$1 } from \"@netcracker/qubership-apihub-json-crawl\";\nimport { JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING, JSON_SCHEMA_NODE_TYPE_BOOLEAN, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY, JSON_SCHEMA_NODE_TYPE_OBJECT, JSON_SCHEMA_NODE_TYPE_ARRAY, JSON_SCHEMA_NODE_TYPE_NUMBER, JSON_SCHEMA_NODE_TYPE_STRING, JSON_SCHEMA_NODE_TYPE_INTEGER, JSON_SCHEMA_NODE_TYPE_NULL, normalize, denormalize, isDefaultValue, resolveOrigins, pathItemToFullPath, JSON_SCHEMA_PROPERTY_ONE_OF, JSON_SCHEMA_PROPERTY_ANY_OF, copyOrigins, JSON_SCHEMA_PROPERTY_TYPE, cleanOrigins, setOrigins, copyDescriptors, SPEC_TYPE_JSON_SCHEMA_04, createEvaluationCacheService, GRAPH_API_PROPERTY_ONE_OF, GRAPH_API_PROPERTY_DIRECTIVES, GRAPH_API_PROPERTY_TITLE, GRAPH_API_PROPERTY_TYPE, GRAPH_API_PROPERTY_KIND, GRAPH_API_PROPERTY_NULLABLE, GRAPH_API_PROPERTY_DEFAULT, GRAPH_API_PROPERTY_LOCATIONS, GRAPH_API_PROPERTY_DEFINITION, SPEC_TYPE_JSON_SCHEMA_07, calculateMatchingDepth, startFromOpenApiComponents, OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue, OPEN_API_PROPERTY_ENCODING, OPEN_API_HTTP_METHODS, OPEN_API_PROPERTY_PATHS, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_RESPONSES, PREDICATE_UNCLOSED_END, OPEN_API_PROPERTY_HEADERS, matchPaths, OPEN_API_PROPERTY_PARAMETERS, OPEN_API_PROPERTY_SCHEMA, OPEN_API_PROPERTY_SCHEMAS, SPEC_TYPE_OPEN_API_30, SPEC_TYPE_OPEN_API_31, JSON_SCHEMA_PROPERTY_NULLABLE, JSON_SCHEMA_PROPERTY_TITLE, OPEN_API_PROPERTY_EXAMPLE, OPEN_API_PROPERTY_EXAMPLES, resolveSpec, SPEC_TYPE_JSON_SCHEMA_06, SPEC_TYPE_ASYNCAPI_2, SPEC_TYPE_GRAPH_API } from \"@netcracker/qubership-apihub-api-unifier\";\nimport { deepEqual } from \"fast-equals\";\nconst FAILED_PARAMS_CALCULATION = {};\nconst IGNORE_DIFFERENCE_IN_KEYS_RULE = \"ignoreKeyDifference\";\nconst START_NEW_COMPARE_SCOPE_RULE = \"newCompareScope\";\nconst COMPARE_SCOPE_ROOT = \"root\";\nconst COMPARE_MODE_DEFAULT = \"default\";\nconst COMPARE_MODE_OPERATION = \"operation\";\nvar ApiCompatibilityKind = /* @__PURE__ */ ((ApiCompatibilityKind2) => {\n  ApiCompatibilityKind2[\"BACKWARD_COMPATIBLE\"] = \"BACKWARD_COMPATIBLE\";\n  ApiCompatibilityKind2[\"NOT_BACKWARD_COMPATIBLE\"] = \"NOT_BACKWARD_COMPATIBLE\";\n  return ApiCompatibilityKind2;\n})(ApiCompatibilityKind || {});\nconst isObject = (value) => {\n  return typeof value === \"object\" && value !== null;\n};\nconst isArray = (value) => {\n  return Array.isArray(value);\n};\nconst isNotEmptyArray = (value) => {\n  return !!(Array.isArray(value) && value.length);\n};\nconst isEmptyArray = (value) => {\n  return Array.isArray(value) && !value.length;\n};\nconst isExist = (value) => {\n  return typeof value !== \"undefined\";\n};\nconst isString = (value) => {\n  return typeof value === \"string\";\n};\nconst isBoolean = (value) => {\n  return typeof value === \"boolean\";\n};\nconst isSymbol = (value) => {\n  return typeof value === \"symbol\";\n};\nconst isNumber = (value) => {\n  return typeof value === \"number\" || isString(value) && !Number.isNaN(+value);\n};\nconst isFunc = (value) => {\n  return typeof value === \"function\";\n};\nconst typeOf = (value) => {\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n  return value === null ? \"null\" : typeof value;\n};\nconst objectKeys = (value) => {\n  return Object.keys(value);\n};\nconst getKeyValue = (obj, ...path) => {\n  let value = obj;\n  for (const key of path) {\n    if (!isSymbol(key) && Array.isArray(value) && typeof +key === \"number\" && value.length < +key) {\n      value = value[+key];\n    } else if (isObject(value) && key in value) {\n      value = value[key];\n    } else {\n      return;\n    }\n    if (value === void 0) {\n      return;\n    }\n  }\n  return value;\n};\nconst getStringValue = (obj, ...path) => {\n  const value = getKeyValue(obj, ...path);\n  return typeof value === \"string\" ? value : void 0;\n};\nconst getObjectValue = (obj, ...path) => {\n  const value = getKeyValue(obj, ...path);\n  return isObject(value) ? value : void 0;\n};\nconst getArrayValue = (obj, ...path) => {\n  const value = getKeyValue(obj, ...path);\n  return Array.isArray(value) ? value : void 0;\n};\nconst JSON_SCHEMA_ASSIGN_TYPE_MAPPING = {\n  [JSON_SCHEMA_NODE_TYPE_BOOLEAN]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_BOOLEAN, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_OBJECT]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_OBJECT, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_ARRAY]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_ARRAY, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_NUMBER]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_NUMBER, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_STRING]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_STRING, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_INTEGER]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_INTEGER, JSON_SCHEMA_NODE_TYPE_NUMBER, JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_TYPE_NULL]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_TYPE_NULL]),\n  [JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]: /* @__PURE__ */ new Set([JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY]),\n  [JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING]: /* @__PURE__ */ new Set(\n    [\n      JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING,\n      JSON_SCHEMA_NODE_TYPE_BOOLEAN,\n      JSON_SCHEMA_NODE_TYPE_OBJECT,\n      JSON_SCHEMA_NODE_TYPE_ARRAY,\n      JSON_SCHEMA_NODE_TYPE_NUMBER,\n      JSON_SCHEMA_NODE_TYPE_STRING,\n      JSON_SCHEMA_NODE_TYPE_INTEGER,\n      JSON_SCHEMA_NODE_TYPE_NULL,\n      JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY\n    ]\n  )\n};\nconst isTypeAssignable = (fromType, toType, covariant) => {\n  if (toType === JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING) {\n    return false;\n  }\n  if (fromType === JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING) {\n    return true;\n  }\n  const from = !covariant ? fromType : toType;\n  const to = !covariant ? toType : fromType;\n  const allowedTypes = JSON_SCHEMA_ASSIGN_TYPE_MAPPING[from];\n  if (!allowedTypes) {\n    return false;\n  }\n  return allowedTypes.has(to);\n};\nconst nonBreakingIf = (v) => v ? nonBreaking : breaking;\nconst isDiffAdd = (diff) => diff.action === DiffAction.add;\nconst isDiffRemove = (diff) => diff.action === DiffAction.remove;\nconst isDiffRename = (diff) => diff.action === DiffAction.rename;\nconst isDiffReplace = (diff) => diff.action === DiffAction.replace;\nconst onlyExistedArrayIndexes = (array) => anyArrayKeys(array).flatMap((value) => typeof value === \"number\" ? [value] : []);\nconst resolveNodeContextFromCompareContext = (diff, ctx) => {\n  return isDiffRemove(diff) ? ctx.before : ctx.after;\n};\nconst resolveCurrentNode = (diff, ctx) => {\n  const context = resolveNodeContextFromCompareContext(diff, ctx);\n  const parent = strictResolveValueFromContext(context);\n  if (!isObject(parent)) {\n    return void 0;\n  }\n  return parent;\n};\nconst resolveParentNode = (diff, ctx) => {\n  const context = resolveNodeContextFromCompareContext(diff, ctx);\n  const parent = strictResolveValueFromContext(context, PARENT_JUMP);\n  if (!isObject(parent)) {\n    return void 0;\n  }\n  return parent;\n};\nconst resolveValueFromCompareContext = (diff, ctx, ...path) => {\n  const context = resolveNodeContextFromCompareContext(diff, ctx);\n  const parent = strictResolveValueFromContext(context, ...path);\n  if (!isObject(parent)) {\n    return void 0;\n  }\n  return parent;\n};\nconst resolveAllDeclarationPath = (diff) => {\n  let declarationPaths;\n  switch (diff.action) {\n    case DiffAction.add:\n      declarationPaths = [...diff.afterDeclarationPaths];\n      break;\n    case DiffAction.remove:\n      declarationPaths = [...diff.beforeDeclarationPaths];\n      break;\n    case DiffAction.replace:\n      declarationPaths = [...diff.beforeDeclarationPaths, ...diff.afterDeclarationPaths];\n      break;\n    case DiffAction.rename:\n      declarationPaths = [...diff.beforeDeclarationPaths, ...diff.afterDeclarationPaths];\n      break;\n  }\n  return declarationPaths;\n};\nconst calculateParentJumpDeep = (deep) => {\n  return [...Array(deep)].fill(PARENT_JUMP);\n};\nconst checkPrimitiveType = (value) => {\n  if (isObject(value)) {\n    return void 0;\n  }\n  if (isString(value) || isBoolean(value) || isNumber(value)) {\n    return value;\n  }\n  return void 0;\n};\nfunction intersection(array1, array2) {\n  const set2 = new Set(array2);\n  return [...new Set(array1.filter((x) => set2.has(x)))];\n}\nfunction difference(array1, array2) {\n  const set2 = new Set(array2);\n  return [...new Set(array1.filter((x) => !set2.has(x)))];\n}\nfunction removeExcessiveSlashes(input) {\n  return input.replace(/\\/+/g, \"/\").replace(/^\\//, \"\");\n}\nfunction aggregateDiffsWithRollup(obj, diffProperty, aggregatedDiffProperty) {\n  const visited = /* @__PURE__ */ new Set();\n  function _aggregateDiffsWithRollup(obj2) {\n    if (!isObject(obj2)) {\n      return void 0;\n    }\n    if (visited.has(obj2)) {\n      return obj2[aggregatedDiffProperty];\n    }\n    visited.add(obj2);\n    const childrenDiffs = new Array();\n    if (Array.isArray(obj2)) {\n      for (const item of obj2) {\n        const childDiffs = _aggregateDiffsWithRollup(item);\n        childDiffs && childDiffs.size > 0 && childrenDiffs.push(childDiffs);\n      }\n    } else {\n      for (const [_, value] of Object.entries(obj2)) {\n        const childDiffs = _aggregateDiffsWithRollup(value);\n        childDiffs && childDiffs.size > 0 && childrenDiffs.push(childDiffs);\n      }\n    }\n    const hasOwnDiffs = diffProperty in obj2;\n    if (hasOwnDiffs || childrenDiffs.length > 1) {\n      const aggregatedDiffs = /* @__PURE__ */ new Set();\n      for (const childDiffs of childrenDiffs) {\n        childDiffs.forEach((diff) => aggregatedDiffs.add(diff));\n      }\n      const diffs = obj2[diffProperty];\n      for (const key in diffs) {\n        aggregatedDiffs.add(diffs[key]);\n      }\n      obj2[aggregatedDiffProperty] = aggregatedDiffs;\n    } else if (childrenDiffs.length === 1) {\n      [obj2[aggregatedDiffProperty]] = childrenDiffs;\n    } else\n      ;\n    return obj2[aggregatedDiffProperty];\n  }\n  return _aggregateDiffsWithRollup(obj);\n}\nconst extractOperationBasePath = (servers) => {\n  if (!Array.isArray(servers) || !servers.length) {\n    return \"\";\n  }\n  try {\n    const [firstServer] = servers;\n    let serverUrl = firstServer.url;\n    if (!serverUrl) {\n      return \"\";\n    }\n    const { variables = {} } = firstServer;\n    for (const param of Object.keys(variables)) {\n      serverUrl = serverUrl.replace(new RegExp(`{${param}}`, \"g\"), variables[param].default);\n    }\n    const { pathname } = new URL(serverUrl, \"https://localhost\");\n    return pathname.slice(-1) === \"/\" ? pathname.slice(0, -1) : pathname;\n  } catch (error) {\n    return \"\";\n  }\n};\nconst DIFF_META_KEY = Symbol(\"$diff\");\nconst DIFFS_AGGREGATED_META_KEY = Symbol(\"$diffs-aggregated\");\nconst DEFAULT_NORMALIZED_RESULT = false;\nconst DEFAULT_OPTION_DEFAULTS_META_KEY = Symbol(\"$defaults\");\nconst DEFAULT_OPTION_ORIGINS_META_KEY = Symbol(\"$origins\");\nconst JSO_ROOT = \"#\";\nconst DiffAction = {\n  add: \"add\",\n  remove: \"remove\",\n  replace: \"replace\",\n  rename: \"rename\"\n};\nconst ClassifierType = {\n  breaking: \"breaking\",\n  nonBreaking: \"non-breaking\",\n  risky: \"risky\",\n  annotation: \"annotation\",\n  unclassified: \"unclassified\",\n  deprecated: \"deprecated\"\n};\nconst { breaking, nonBreaking, risky, unclassified, annotation, deprecated } = ClassifierType;\nconst allNonBreaking = [nonBreaking, nonBreaking, nonBreaking];\nconst allBreaking = [breaking, breaking, breaking];\nconst onlyAddBreaking = [breaking, nonBreaking, nonBreaking];\nconst addNonBreaking = [nonBreaking, breaking, breaking];\nconst allUnclassified = [unclassified, unclassified, unclassified];\nconst allAnnotation = [annotation, annotation, annotation];\nconst allDeprecated = [deprecated, deprecated, deprecated];\nconst ANY_COMBINER_INDEX = -1;\nconst ANY_COMBINER_PATH = [];\nconst diffDescription = (descriptionTemplate) => {\n  const diffDescriptionRule = (diff, ctx) => {\n    const paramCalculator = resolveParamCalculator(ctx);\n    if (paramCalculator === void 0) {\n      return void 0;\n    }\n    const params = paramCalculator(diff, ctx);\n    if (params === FAILED_PARAMS_CALCULATION) {\n      return void 0;\n    }\n    return createDescription(isArray(descriptionTemplate) ? descriptionTemplate : [descriptionTemplate], params);\n  };\n  return diffDescriptionRule;\n};\nconst resolveParamCalculator = (ctx) => {\n  if (ctx === void 0) {\n    return void 0;\n  }\n  const descriptionParamCalculator = ctx.rules.descriptionParamCalculator;\n  if (descriptionParamCalculator) {\n    return descriptionParamCalculator;\n  }\n  return resolveParamCalculator(ctx.parentContext);\n};\nconst getDeclarationPathsForDiff = (diff) => {\n  switch (diff.action) {\n    case DiffAction.add:\n      return [...diff.afterDeclarationPaths];\n    case DiffAction.remove:\n      return [...diff.beforeDeclarationPaths];\n    case DiffAction.replace:\n      if (diff.afterDeclarationPaths) {\n        return [...diff.afterDeclarationPaths];\n      } else {\n        return [...diff.beforeDeclarationPaths];\n      }\n    case DiffAction.rename:\n      if (diff.afterDeclarationPaths) {\n        return [...diff.afterDeclarationPaths];\n      } else {\n        return [...diff.beforeDeclarationPaths];\n      }\n  }\n};\nconst calculateDefaultDiffDescription = (diff) => {\n  const declarationPaths = getDeclarationPathsForDiff(diff);\n  const paths = declarationPaths.map((path) => `'${path.join(\".\")}'`).join(\", \");\n  if (diff.scope) {\n    return `[${DIFF_ACTION_TO_ACTION_MAP[diff.action]}] ${paths} in ${diff.scope}`;\n  }\n  return `[${DIFF_ACTION_TO_ACTION_MAP[diff.action]}] ${paths}`;\n};\nconst createDescription = (descriptionTemplates, params) => {\n  if (isEmptyArray(descriptionTemplates)) {\n    return \"\";\n  }\n  return applyTemplateParams(descriptionTemplates, params);\n};\nconst applyTemplateParams = (templates, params) => {\n  const template = findTemplate(templates, params);\n  if (!template) {\n    return void 0;\n  }\n  return applyTempleParams(template, params);\n};\nconst findTemplate = (templates, params) => {\n  var _a;\n  return (_a = templates.reduce((suitableTemplate, template) => {\n    const templateParams = [...template.matchAll(/{{(\\w+)}}/g)].map((matchResult) => matchResult[0]).map((param) => param.slice(2, -2));\n    let suitability = 0;\n    for (const templateParam of templateParams) {\n      if (params[templateParam] === void 0) {\n        return suitableTemplate;\n      }\n      suitability += 1;\n    }\n    return suitableTemplate && suitableTemplate.suitability > suitability ? suitableTemplate : { template, suitability };\n  }, void 0)) == null ? void 0 : _a.template;\n};\nconst applyTempleParams = (template, params) => {\n  if (!template) {\n    return \"\";\n  }\n  const placeholders = {};\n  for (const key of objectKeys(params)) {\n    placeholders[key] = params[key];\n  }\n  for (const match of [...template.matchAll(/{{(\\w+)}}/g)].reverse()) {\n    if (!(match[1] in placeholders)) {\n      continue;\n    }\n    const index = match.index ?? 0;\n    template = template.substring(0, index) + String(placeholders[match[1]]) + template.substring(index + match[0].length);\n  }\n  return template;\n};\nconst DIFF_ACTION_TO_PREPOSITION_MAP = {\n  [DiffAction.add]: \"to\",\n  [DiffAction.remove]: \"from\",\n  [DiffAction.replace]: \"for\",\n  [DiffAction.rename]: \"of\"\n};\nconst DIFF_ACTION_TO_ACTION_MAP = {\n  [DiffAction.add]: \"Added\",\n  [DiffAction.remove]: \"Deleted\",\n  [DiffAction.replace]: \"Changed\",\n  [DiffAction.rename]: \"Renamed\"\n};\nconst GREP_TEMPLATE_PARAM_HEADER_NAME = \"headerName\";\nconst GREP_TEMPLATE_PARAM_RESPONSE_NAME = \"responseName\";\nconst GREP_TEMPLATE_PARAM_EXAMPLE_NAME = \"exampleName\";\nconst GREP_TEMPLATE_PARAM_PARAMETER_NAME = \"parameterName\";\nconst GREP_TEMPLATE_PARAM_MEDIA_TYPE = \"mediaType\";\nconst GREP_TEMPLATE_PARAM_ENCODING_NAME = \"encodingName\";\nconst TEMPLATE_PARAM_ACTION = \"action\";\nconst TEMPLATE_PARAM_PREPOSITION = \"preposition\";\nconst TEMPLATE_PARAM_PROPERTY_NAME = \"propertyName\";\nconst TEMPLATE_PARAM_RESPONSE_PATH = \"responsePath\";\nconst TEMPLATE_PARAM_REQUEST_PATH = \"requestPath\";\nconst TEMPLATE_PARAM_HEADER_PATH = \"headerPath\";\nconst TEMPLATE_PARAM_EXAMPLE_PATH = \"examplePath\";\nconst TEMPLATE_PARAM_PARAMETER_PATH = \"parameterPath\";\nconst TEMPLATE_PARAM_SCHEMA_PATH = \"schemaPath\";\nconst TEMPLATE_PARAM_COMPONENT_PATH = \"componentPath\";\nconst TEMPLATE_PARAM_PARAMETER_LOCATION = \"parameterLocation\";\nconst TEMPLATE_PARAM_PLACE = \"place\";\nconst TEMPLATE_PARAM_SCOPE = \"scope\";\nconst NEVER_KEY = Symbol(\"never-key\");\nconst createDiff = (diff, ctx) => {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const classifierRule = ((_a = ctx.rules) == null ? void 0 : _a.$) ?? {};\n  const mutableDiffCopy = { ...diff, type: unclassified };\n  if (classifierRule) {\n    const classifier = Array.isArray(classifierRule) ? classifierRule : allUnclassified;\n    const index = diff.action === DiffAction.rename ? 2 : [DiffAction.add, DiffAction.remove, DiffAction.replace].indexOf(diff.action);\n    const changeType = classifier[index];\n    try {\n      const type = isFunc(changeType) ? changeType(ctx) : changeType;\n      mutableDiffCopy.type = reclassifyBreakingToRisky(type, ctx);\n    } catch (error) {\n      (_c = (_b = ctx.options).onCreateDiffError) == null ? void 0 : _c.call(_b, `Unable to find diff type. ${error instanceof Error ? error.message : \"\"}`, mutableDiffCopy, ctx);\n    }\n  }\n  try {\n    mutableDiffCopy.description = ((_e = (_d = ctx.rules).description) == null ? void 0 : _e.call(_d, mutableDiffCopy, ctx)) ?? calculateDefaultDiffDescription(mutableDiffCopy);\n  } catch (error) {\n    (_g = (_f = ctx.options).onCreateDiffError) == null ? void 0 : _g.call(_f, `Unable to create description for diff. ${error instanceof Error ? error.message : \"\"}`, mutableDiffCopy, ctx);\n  }\n  return mutableDiffCopy;\n};\nconst reclassifyBreakingToRisky = (type, ctx) => {\n  return type === breaking && ctx.apiCompatibilityScope === ApiCompatibilityKind.NOT_BACKWARD_COMPATIBLE ? risky : type;\n};\nfunction createDiffEntry(ctx, diff) {\n  return {\n    propertyKey: ctx.mergeKey,\n    diff\n  };\n}\nconst diffFactory = {\n  added: (ctx) => {\n    var _a, _b;\n    const diff = createDiff({\n      afterValue: (_a = ctx.after) == null ? void 0 : _a.value,\n      action: DiffAction.add,\n      afterDeclarationPaths: ctx.after.declarativePaths,\n      scope: ctx.scope\n    }, ctx);\n    if (ctx.options.afterValueNormalizedProperty) {\n      diff[ctx.options.afterValueNormalizedProperty] = (_b = ctx.after) == null ? void 0 : _b.value;\n    }\n    return diff;\n  },\n  removed: (ctx) => {\n    const diff = createDiff({\n      beforeValue: ctx.before.value,\n      action: DiffAction.remove,\n      beforeDeclarationPaths: ctx.before.declarativePaths,\n      scope: ctx.scope\n    }, ctx);\n    if (ctx.options.beforeValueNormalizedProperty) {\n      diff[ctx.options.beforeValueNormalizedProperty] = ctx.before.value;\n    }\n    return diff;\n  },\n  replaced: (ctx) => {\n    const diff = createDiff({\n      beforeValue: ctx.before.value,\n      afterValue: ctx.after.value,\n      action: DiffAction.replace,\n      afterDeclarationPaths: ctx.after.declarativePaths,\n      beforeDeclarationPaths: ctx.before.declarativePaths,\n      scope: ctx.scope\n    }, ctx);\n    if (ctx.options.beforeValueNormalizedProperty) {\n      diff[ctx.options.beforeValueNormalizedProperty] = ctx.before.value;\n    }\n    if (ctx.options.afterValueNormalizedProperty) {\n      diff[ctx.options.afterValueNormalizedProperty] = ctx.after.value;\n    }\n    return diff;\n  },\n  renamed: (ctx) => {\n    var _a, _b, _c, _d;\n    return createDiff({\n      beforeKey: (_a = ctx.before) == null ? void 0 : _a.key,\n      afterKey: (_b = ctx.after) == null ? void 0 : _b.key,\n      action: DiffAction.rename,\n      afterDeclarationPaths: ((_c = ctx.after) == null ? void 0 : _c.declarativePaths) ?? [],\n      beforeDeclarationPaths: ((_d = ctx.before) == null ? void 0 : _d.declarativePaths) ?? [],\n      scope: ctx.scope\n    }, ctx);\n  }\n};\nconst addDiffObjectToContainer = (container, diffMetaKey, diffs) => {\n  if (diffMetaKey === void 0 || diffs.length === 0) {\n    return;\n  }\n  const metaRecord = diffMetaKey in container ? container[diffMetaKey] : {};\n  diffs.forEach(({ propertyKey, diff }) => metaRecord[propertyKey] = diff);\n  container[diffMetaKey] = metaRecord;\n};\nconst PARENT_JUMP = \"..\";\nconst strictResolveValueFromContext = (ctx, ...path) => resolveValueFromContext(true, ctx, ...path);\nconst optionalResolveValueFromContext = (ctx, ...path) => resolveValueFromContext(false, ctx, ...path);\nconst resolveValueFromContext = (strict, ctx, ...path) => {\n  if (path.length === 0) {\n    return ctx.value;\n  }\n  let fromObj = ctx.value;\n  let fromContext = ctx;\n  let countParentJump = 0;\n  for (const pathItem of path) {\n    if (pathItem !== PARENT_JUMP) {\n      break;\n    }\n    if (!(fromContext == null ? void 0 : fromContext.parentContext)) {\n      if (strict) {\n        throw Error(`Could not get data from the context along path '${path.join(\"/\")}'`);\n      } else {\n        return void 0;\n      }\n    }\n    fromContext = fromContext == null ? void 0 : fromContext.parentContext;\n    fromObj = fromContext == null ? void 0 : fromContext.value;\n    countParentJump += 1;\n  }\n  path = path.slice(countParentJump);\n  return getKeyValue(fromObj, ...path);\n};\nconst arrayMappingResolver = (before, after) => {\n  const length = Math.abs(before.length - after.length);\n  const arr = Array.from({ length: Math.min(before.length, after.length) }, (_, i) => i);\n  return {\n    removed: before.length > after.length ? Array.from({ length }, (_, i) => after.length + i) : [],\n    added: before.length < after.length ? Array.from({ length }, (_, i) => before.length + i) : [],\n    mapped: arr.reduce((res, i) => {\n      res[i] = i;\n      return res;\n    }, {})\n  };\n};\nconst customUniqueItemsArrayMappingResolver = (equalityFn) => (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const beforeArrayIndexes = onlyExistedArrayIndexes(before);\n  const afterArrayIndexes = onlyExistedArrayIndexes(after);\n  const beforeMatchedArrayIndexes = new Set(beforeArrayIndexes);\n  const afterMatchedArrayIndexes = new Set(afterArrayIndexes);\n  for (const i of beforeArrayIndexes) {\n    const beforeItem = before[i];\n    for (const j of afterArrayIndexes) {\n      if (!afterMatchedArrayIndexes.has(j)) {\n        continue;\n      }\n      const afterItem = after[j];\n      if (equalityFn(beforeItem, afterItem)) {\n        afterMatchedArrayIndexes.delete(j);\n        beforeMatchedArrayIndexes.delete(i);\n        result.mapped[i] = j;\n        break;\n      }\n    }\n  }\n  for (const j of afterMatchedArrayIndexes.values()) {\n    result.added.push(j);\n  }\n  for (const i of beforeMatchedArrayIndexes.values()) {\n    result.removed.push(i);\n  }\n  return result;\n};\nconst deepEqualsUniqueItemsArrayMappingResolver = customUniqueItemsArrayMappingResolver(deepEqual);\nconst objectMappingResolver = (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const afterKeys = new Set(Object.keys(after));\n  for (const key of Object.keys(before)) {\n    if (afterKeys.has(key)) {\n      result.mapped[key] = key;\n      afterKeys.delete(key);\n    } else {\n      result.removed.push(key);\n    }\n  }\n  afterKeys.forEach((key) => result.added.push(key));\n  return result;\n};\nconst extractDeclarationPaths = (jso, originMetaKey, property) => {\n  const origins = resolveOrigins(jso, property, originMetaKey);\n  if (!origins) {\n    return [];\n  }\n  return origins.map((leaf) => pathItemToFullPath(leaf));\n};\nfunction createNodeContext(parentContext, jso, key, value, options, root) {\n  return {\n    parentContext,\n    key,\n    declarativePaths: extractDeclarationPaths(jso, options.originsFlag, key),\n    parent: jso,\n    value,\n    root\n  };\n}\nconst createContext = (data, options) => {\n  const {\n    beforeJso,\n    afterJso,\n    root,\n    afterKey,\n    beforeKey,\n    mergeKey,\n    beforeValue,\n    afterValue,\n    rules,\n    compareScope,\n    parentContext,\n    apiCompatibilityScope\n  } = data;\n  return {\n    parentContext,\n    scope: compareScope,\n    before: createNodeContext(parentContext == null ? void 0 : parentContext.before, beforeJso, beforeKey, beforeValue, options, root.before[JSO_ROOT]),\n    after: createNodeContext(parentContext == null ? void 0 : parentContext.after, afterJso, afterKey, afterValue, options, root.after[JSO_ROOT]),\n    mergeKey,\n    rules,\n    options,\n    apiCompatibilityScope\n  };\n};\nconst createChildContext = (ctx, mergedKey, beforeChildKey, afterChildKey, apiCompatibilityScope = ctx.apiCompatibilityScope) => {\n  const { before, after, rules, options, scope } = ctx;\n  let beforeContext;\n  if (beforeChildKey !== void 0 && isObject(before.value)) {\n    beforeContext = createNodeContext(before, before.value, beforeChildKey, before.value[beforeChildKey], options, before.root);\n  } else {\n    beforeContext = {\n      parentContext: before,\n      declarativePaths: [],\n      key: NEVER_KEY,\n      value: void 0,\n      parent: before == null ? void 0 : before.value,\n      root: before == null ? void 0 : before.root\n    };\n  }\n  let afterContext;\n  if (afterChildKey !== void 0 && isObject(after.value)) {\n    afterContext = createNodeContext(after, after.value, afterChildKey, after.value[afterChildKey], options, after.root);\n  } else {\n    afterContext = {\n      parentContext: after,\n      declarativePaths: [],\n      key: NEVER_KEY,\n      value: void 0,\n      parent: after == null ? void 0 : after.value,\n      root: after == null ? void 0 : after.root\n    };\n  }\n  return {\n    parentContext: ctx,\n    before: beforeContext,\n    after: afterContext,\n    mergeKey: mergedKey,\n    rules: getNodeRules(\n      rules,\n      beforeChildKey ?? afterChildKey ?? NEVER_KEY,\n      ANY_COMBINER_PATH,\n      afterContext.value ?? beforeContext.value ?? void 0\n    ) ?? {},\n    options,\n    scope,\n    apiCompatibilityScope\n  };\n};\nconst buildPathsIdentifier = (paths) => {\n  return paths.map((path) => path.join(\"|\")).sort().join(\"\\n\");\n};\nconst cleanUpRecursive = (ctx) => {\n  if (!isObject(ctx.value)) {\n    return ctx;\n  }\n  let lastGoodContext = ctx;\n  let currentContext = ctx;\n  while (currentContext) {\n    if (currentContext.value === ctx.value) {\n      lastGoodContext = currentContext;\n    }\n    currentContext = currentContext.parentContext;\n  }\n  return lastGoodContext;\n};\nconst getOrCreateChildDiffAdd = (diffUniquenessCache, childCtx) => {\n  const diff = diffUniquenessCache.cacheEvaluationResultByFootprint([\n    childCtx.after.value,\n    buildPathsIdentifier(childCtx.after.declarativePaths),\n    childCtx.scope,\n    DiffAction.add,\n    childCtx.apiCompatibilityScope\n  ], () => {\n    return diffFactory.added(childCtx);\n  }, {}, (result, guard) => {\n    Object.assign(guard, result);\n    return guard;\n  });\n  return createDiffEntry(childCtx, diff);\n};\nconst getOrCreateChildDiffRemove = (diffUniquenessCache, childCtx) => {\n  const diff = diffUniquenessCache.cacheEvaluationResultByFootprint([\n    childCtx.before.value,\n    buildPathsIdentifier(childCtx.before.declarativePaths),\n    childCtx.scope,\n    DiffAction.remove,\n    childCtx.apiCompatibilityScope\n  ], () => {\n    return diffFactory.removed(childCtx);\n  }, {}, (result, guard) => {\n    Object.assign(guard, result);\n    return guard;\n  });\n  return createDiffEntry(childCtx, diff);\n};\nconst adaptValues = (beforeJso, beforeKey, afterJso, afterKey, adapter, options) => {\n  const beforeValue = beforeJso[beforeKey];\n  const afterValue = afterJso[afterKey];\n  if (!adapter) {\n    return [beforeValue, afterValue];\n  }\n  let beforeValueAdapted = beforeValue;\n  let afterValueAdapted = afterValue;\n  const transformer = (value, transformId, f) => options.valueAdaptationCache.cacheEvaluationResultByFootprint([value, transformId], ([value2]) => f(value2));\n  const beforeCtx = {\n    transformer,\n    options,\n    valueOrigins: resolveOrigins(beforeJso, beforeKey, options.originsFlag)\n  };\n  const afterCtx = {\n    transformer,\n    options,\n    valueOrigins: resolveOrigins(afterJso, afterKey, options.originsFlag)\n  };\n  adapter == null ? void 0 : adapter.forEach((f) => {\n    beforeValueAdapted = f(beforeValueAdapted, afterValueAdapted, beforeCtx);\n    afterValueAdapted = f(afterValueAdapted, beforeValueAdapted, afterCtx);\n  });\n  return [beforeValueAdapted, afterValueAdapted];\n};\nconst useMergeFactory = (onDiff, options) => {\n  const { metaKey, apiCompatibilityScopeFunction } = options;\n  const diffs = /* @__PURE__ */ new Set();\n  const addDiff = (diff) => {\n    const oldSize = diffs.size;\n    diffs.add(diff);\n    if (diffs.size !== oldSize)\n      onDiff(diff);\n  };\n  const hook = (crawlContext) => {\n    const { rules = {}, state, value, key: unsafeKey } = crawlContext;\n    const {\n      adapter,\n      compare: compare2,\n      mapping,\n      ignoreKeyDifference,\n      newCompareScope\n    } = rules;\n    const {\n      keyMap: keyMap2,\n      beforeJso,\n      afterJso,\n      mergedJso,\n      mergedJsoCache,\n      diffUniquenessCache,\n      createdMergedJso,\n      compareScope,\n      apiCompatibilityScope: parentApiCompatibilityScope\n    } = state;\n    if (typeof unsafeKey === \"symbol\") {\n      return { done: true };\n    }\n    const beforeKey = unsafeKey ?? (isArray(beforeJso) ? +Object.keys(keyMap2).pop() : Object.keys(keyMap2).pop());\n    const afterKey = keyMap2[beforeKey];\n    const mergeKey = isArray(mergedJso) && isNumber(beforeKey) ? beforeKey : afterKey;\n    if (!(beforeKey in keyMap2)) {\n      mergedJso[beforeKey] = value;\n      return { done: true };\n    }\n    const [\n      beforeValueAdapted,\n      afterValueAdapted\n    ] = adaptValues(beforeJso, beforeKey, afterJso, afterKey, adapter, options);\n    const computedApiCompatibilityScope = (apiCompatibilityScopeFunction == null ? void 0 : apiCompatibilityScopeFunction(crawlContext.path, beforeValueAdapted, afterValueAdapted)) ?? parentApiCompatibilityScope;\n    const ctx = createContext({\n      ...state,\n      beforeValue: beforeValueAdapted,\n      afterValue: afterValueAdapted,\n      afterKey,\n      beforeKey,\n      mergeKey,\n      rules,\n      compareScope: newCompareScope ?? compareScope,\n      apiCompatibilityScope: computedApiCompatibilityScope\n    }, options);\n    const beforeDeclarativePathsId = buildPathsIdentifier(cleanUpRecursive(ctx.before).declarativePaths);\n    const afterDeclarativePathsId = buildPathsIdentifier(cleanUpRecursive(ctx.after).declarativePaths);\n    const reuseResult = mergedJsoCache.cacheEvaluationResultByFootprint([\n      ctx.before.value,\n      ctx.after.value,\n      beforeDeclarativePathsId,\n      afterDeclarativePathsId,\n      ctx.scope,\n      computedApiCompatibilityScope\n    ], ([beforeValue, afterValue]) => {\n      if (!ignoreKeyDifference && beforeKey !== afterKey) {\n        const diffEntry = createDiffEntry(ctx, diffFactory.renamed(ctx));\n        addDiff(diffEntry.diff);\n        addDiffObjectToContainer(mergedJso, metaKey, [diffEntry]);\n      }\n      const compared = compare2 == null ? void 0 : compare2(ctx);\n      if (compared) {\n        const { diffs: customComparedDiffs, ownerDiffEntry: ownerDiff, merged } = compared;\n        customComparedDiffs.forEach((diff) => addDiff(diff));\n        return { diffsToPullUp: ownerDiff ? [ownerDiff] : [], mergedValue: merged };\n      }\n      if (typeOf(beforeValue) !== typeOf(afterValue)) {\n        const diffEntry = createDiffEntry(ctx, diffFactory.replaced(ctx));\n        addDiff(diffEntry.diff);\n        return { diffsToPullUp: [diffEntry], mergedValue: afterValue };\n      }\n      if (isObject(beforeValue) && isObject(afterValue)) {\n        const mergedJsoValue = isArray(beforeValue) ? [] : {};\n        const mapKeys = mapping ?? (isArray(beforeValue) ? arrayMappingResolver : objectMappingResolver);\n        const {\n          added: addedKeys,\n          removed: removedKeys,\n          mapped: mappedKeys\n        } = mapKeys(beforeValue, afterValue, ctx);\n        const jsoDiffEntries = [];\n        const keyToRemove = removedKeys.filter((key) => !isDefaultValue(beforeValue, key, options.defaultsFlag));\n        const keysToAdd = addedKeys.filter((key) => !isDefaultValue(afterValue, key, options.defaultsFlag));\n        let once = false;\n        const exitHook = () => {\n          if (once) {\n            return;\n          }\n          once = true;\n          keyToRemove.forEach((keyToBefore) => {\n            const removalBwc = computedApiCompatibilityScope === ApiCompatibilityKind.NOT_BACKWARD_COMPATIBLE ? computedApiCompatibilityScope : apiCompatibilityScopeFunction == null ? void 0 : apiCompatibilityScopeFunction(crawlContext.path, beforeValue[keyToBefore]);\n            const childCtx = createChildContext(ctx, keyToBefore, keyToBefore, void 0, removalBwc);\n            jsoDiffEntries.push(getOrCreateChildDiffRemove(diffUniquenessCache, childCtx));\n          });\n          keysToAdd.forEach((keyInAfter) => {\n            const additionBwc = computedApiCompatibilityScope === ApiCompatibilityKind.NOT_BACKWARD_COMPATIBLE ? computedApiCompatibilityScope : apiCompatibilityScopeFunction == null ? void 0 : apiCompatibilityScopeFunction(crawlContext.path, void 0, afterJso[keyInAfter]);\n            const keyInMerge = isArray(mergedJsoValue) ? mergedJsoValue.length : keyInAfter;\n            const childCtx = createChildContext(ctx, keyInMerge, void 0, keyInAfter, additionBwc);\n            jsoDiffEntries.push(getOrCreateChildDiffAdd(diffUniquenessCache, childCtx));\n            mergedJsoValue[keyInMerge] = afterValue[keyInAfter];\n          });\n          jsoDiffEntries.forEach((e) => addDiff(e.diff));\n          addDiffObjectToContainer(mergedJsoValue, metaKey, jsoDiffEntries);\n        };\n        return {\n          mergedValue: mergedJsoValue,\n          nextValue: beforeValue,\n          nextMappedKeys: mappedKeys,\n          exitHook\n        };\n      }\n      const diffsToPullUp = [];\n      const res = {\n        mergedValue: afterValue,\n        diffsToPullUp\n      };\n      if (beforeValue !== afterValue) {\n        const diffEntry = createDiffEntry(ctx, diffFactory.replaced(ctx));\n        diffsToPullUp.push(diffEntry);\n        addDiff(diffEntry.diff);\n      }\n      return res;\n    });\n    mergedJso[mergeKey] = reuseResult.mergedValue;\n    if (\"diffsToPullUp\" in reuseResult) {\n      addDiffObjectToContainer(mergedJso, metaKey, reuseResult.diffsToPullUp);\n    }\n    if (\"nextValue\" in reuseResult) {\n      const mergedValue = reuseResult.mergedValue;\n      if (createdMergedJso.has(mergedValue)) {\n        return { done: true };\n      }\n      createdMergedJso.add(mergedValue);\n      const childState = {\n        ...crawlContext.state,\n        parentContext: ctx,\n        keyMap: reuseResult.nextMappedKeys,\n        beforeJso: beforeValueAdapted,\n        afterJso: afterValueAdapted,\n        mergedJso: mergedValue,\n        compareScope: newCompareScope ?? compareScope,\n        apiCompatibilityScope: computedApiCompatibilityScope\n      };\n      return { value: reuseResult.nextValue, state: childState, exitHook: reuseResult.exitHook };\n    } else {\n      return { done: true };\n    }\n  };\n  return hook;\n};\nfunction denormalizeWithDiffsSave(merged, options) {\n  const jsoWithoutDiff = /* @__PURE__ */ new Set();\n  const jsoWithDiff = /* @__PURE__ */ new Set();\n  return denormalize(\n    merged,\n    {\n      ...options,\n      source: merged,\n      ...options.metaKey !== void 0 ? {\n        skip: (value, path) => {\n          const metaKey = options.metaKey;\n          if (path.length === 0) {\n            return false;\n          }\n          const key = path[path.length - 1];\n          const containerJsonPath = path.slice(0, path.length - 1);\n          const jso = getObjectValue(merged, ...containerJsonPath);\n          if (jso !== void 0) {\n            const diffs = jso[metaKey];\n            if (isObject(diffs) && key in diffs) {\n              jsoWithDiff.add(jso);\n              return true;\n            }\n          }\n          if (isObject(value)) {\n            let found = false;\n            const operationObjects = /* @__PURE__ */ new Set();\n            syncCrawl(value, ({ value: innerValue }) => {\n              if (!isObject(innerValue)) {\n                return { done: true };\n              }\n              if (jsoWithoutDiff.has(innerValue)) {\n                return { done: true };\n              }\n              if (jsoWithDiff.has(innerValue)) {\n                found = true;\n                return { terminate: true };\n              }\n              if (operationObjects.has(innerValue)) {\n                return { done: true };\n              }\n              operationObjects.add(innerValue);\n              if (metaKey in innerValue) {\n                found = true;\n                return { terminate: true };\n              }\n            });\n            if (found) {\n              operationObjects.forEach((v) => jsoWithDiff.add(v));\n              return true;\n            } else {\n              operationObjects.forEach((v) => jsoWithoutDiff.add(v));\n              return false;\n            }\n          }\n        }\n      } : {}\n    }\n  );\n}\nfunction addNormalizedValuesToDenormalizedDiff(denormalizedDiffs, rawDiffs, beforeValueNormalizedProperty, afterValueNormalizedProperty) {\n  for (let i = 0; i < denormalizedDiffs.length && i < rawDiffs.length; i++) {\n    const denormalizedDiff = denormalizedDiffs[i];\n    const normalizedDiff = rawDiffs[i];\n    if (isDiffAdd(normalizedDiff) && isDiffAdd(denormalizedDiff)) {\n      if (afterValueNormalizedProperty && normalizedDiff[afterValueNormalizedProperty] !== void 0) {\n        denormalizedDiff[afterValueNormalizedProperty] = normalizedDiff[afterValueNormalizedProperty];\n      }\n    } else if (isDiffRemove(normalizedDiff) && isDiffRemove(denormalizedDiff)) {\n      if (beforeValueNormalizedProperty && normalizedDiff[beforeValueNormalizedProperty] !== void 0) {\n        denormalizedDiff[beforeValueNormalizedProperty] = normalizedDiff[beforeValueNormalizedProperty];\n      }\n    } else if (isDiffReplace(normalizedDiff) && isDiffReplace(denormalizedDiff)) {\n      if (afterValueNormalizedProperty && normalizedDiff[afterValueNormalizedProperty] !== void 0) {\n        denormalizedDiff[afterValueNormalizedProperty] = normalizedDiff[afterValueNormalizedProperty];\n      }\n      if (beforeValueNormalizedProperty && normalizedDiff[beforeValueNormalizedProperty] !== void 0) {\n        denormalizedDiff[beforeValueNormalizedProperty] = normalizedDiff[beforeValueNormalizedProperty];\n      }\n    }\n  }\n}\nconst compare = (before, after, options) => {\n  const beforeFullyResolved = normalize(before, {\n    ...options,\n    source: options.beforeSource\n  });\n  const afterFullyResolved = normalize(after, {\n    ...options,\n    source: options.afterSource\n  });\n  const rawDiffs = [];\n  const onDiff = (diff) => rawDiffs.push(diff);\n  let merged = compareInternal(beforeFullyResolved, afterFullyResolved, onDiff, options);\n  if (options.normalizedResult) {\n    return {\n      diffs: rawDiffs,\n      ownerDiffEntry: void 0,\n      merged\n    };\n  }\n  const diffFlags = Symbol(\"diffs\");\n  if (isObject(merged)) {\n    merged[diffFlags] = rawDiffs;\n  }\n  merged = denormalizeWithDiffsSave(merged, options);\n  let denormalizedDiffs = rawDiffs;\n  if (isObject(merged)) {\n    denormalizedDiffs = merged[diffFlags];\n    delete merged[diffFlags];\n  }\n  addNormalizedValuesToDenormalizedDiff(\n    denormalizedDiffs,\n    rawDiffs,\n    options.beforeValueNormalizedProperty,\n    options.afterValueNormalizedProperty\n  );\n  return {\n    diffs: denormalizedDiffs,\n    ownerDiffEntry: void 0,\n    merged\n  };\n};\nconst nestedCompare = (before, after, options) => {\n  const diffs = [];\n  const merged = compareInternal(before, after, (diff) => diffs.push(diff), options);\n  return { merged, diffs, ownerDiffEntry: void 0 };\n};\nconst compareInternal = (before, after, onDiff, options) => {\n  const root = {\n    before: { [JSO_ROOT]: before },\n    after: { [JSO_ROOT]: after },\n    merged: {}\n  };\n  const beforeRootJso = root.before;\n  const afterRootJso = root.after;\n  if (!isObject(beforeRootJso) || !isObject(afterRootJso)) {\n    throw new Error(\"Not ready to compare primitive\");\n  }\n  const hook = useMergeFactory(onDiff, options);\n  const rootState = {\n    parentContext: void 0,\n    mergedJso: root.merged,\n    beforeJso: beforeRootJso,\n    afterJso: afterRootJso,\n    keyMap: { [JSO_ROOT]: JSO_ROOT },\n    root,\n    mergedJsoCache: options.mergedJsoCache,\n    diffUniquenessCache: options.diffUniquenessCache,\n    createdMergedJso: options.createdMergedJso,\n    compareScope: options.compareScope,\n    apiCompatibilityScope: ApiCompatibilityKind.BACKWARD_COMPATIBLE\n  };\n  syncCrawl(before, [hook], { state: rootState, rules: options.rules });\n  return root.merged[JSO_ROOT];\n};\nconst transformCompareRules = (rules, transformer) => {\n  return syncClone(rules, ({ value, key, state, path }) => {\n    if (key && (!isString(key) || !key.startsWith(\"/\"))) {\n      state.node[key] = value;\n      return { done: true };\n    }\n    if (typeof value === \"function\") {\n      return { value: (...args) => transformCompareRules(value(...args), transformer) };\n    } else if (!Array.isArray(value) && isObject(value)) {\n      return { value: transformer(value) };\n    }\n  });\n};\nconst reverseClassifyRuleTransformer = (value) => {\n  if (\"$\" in value && Array.isArray(value.$)) {\n    return { ...value, $: reverseClassifyRule(value.$) };\n  }\n  return value;\n};\nconst reverseDiffType = (diffType) => {\n  if (typeof diffType === \"function\") {\n    return (ctx) => reverseDiffType(diffType(ctx));\n  } else {\n    switch (diffType) {\n      case breaking:\n        return nonBreaking;\n      case nonBreaking:\n        return breaking;\n      default:\n        return diffType;\n    }\n  }\n};\nconst reverseClassifyRule = ([add, remove, replace, reverseAdd, reverseRemove, reverseReplace]) => {\n  return [\n    reverseAdd ?? reverseDiffType(add),\n    reverseRemove ?? reverseDiffType(remove),\n    reverseReplace ?? reverseDiffType(replace)\n  ];\n};\nconst transformClassifyRule = ([add, remove, replace, reverseAdd, reverseRemove, reverseReplace], transformer) => {\n  const transformedRule = (ruleDiffType, diffAction) => (ctx) => transformer(isFunc(ruleDiffType) ? ruleDiffType(ctx) : ruleDiffType, ctx, diffAction);\n  if (reverseAdd !== void 0 && reverseRemove !== void 0 && reverseReplace !== void 0) {\n    return [\n      transformedRule(add, DiffAction.add),\n      transformedRule(remove, DiffAction.remove),\n      transformedRule(replace, DiffAction.replace),\n      transformedRule(reverseAdd, DiffAction.add),\n      transformedRule(reverseRemove, DiffAction.remove),\n      transformedRule(reverseReplace, DiffAction.replace)\n    ];\n  }\n  return [\n    transformedRule(add, DiffAction.add),\n    transformedRule(remove, DiffAction.remove),\n    transformedRule(replace, DiffAction.replace)\n  ];\n};\nconst breakingIf = (v) => v ? breaking : nonBreaking;\nconst riskyIf = (v) => v ? risky : nonBreaking;\nconst breakingIfAfterTrue = ({ after }) => breakingIf(!!after.value);\nconst booleanClassifier = [\n  breakingIfAfterTrue,\n  nonBreaking,\n  breakingIfAfterTrue\n];\nconst typeClassifier = [\n  breaking,\n  //not tested\n  breaking,\n  //not tested\n  ({ before, after }) => nonBreakingIf(isTypeAssignable(before.value, after.value, false)),\n  breaking,\n  //not tested\n  breaking,\n  //not tested\n  ({ before, after }) => nonBreakingIf(isTypeAssignable(before.value, after.value, true))\n];\nconst maxClassifier = [\n  breaking,\n  nonBreaking,\n  ({ before, after }) => breakingIf(!isNumber(before.value) || !isNumber(after.value) || before.value > after.value)\n];\nconst minClassifier = [\n  breaking,\n  nonBreaking,\n  ({ before, after }) => breakingIf(!isNumber(before.value) || !isNumber(after.value) || before.value < after.value)\n];\nconst minimumClassifier = [\n  ({ before, after }) => {\n    const beforeExclusiveMinimum = getKeyValue(before.parent, \"exclusiveMinimum\");\n    return breakingIf(!isNumber(beforeExclusiveMinimum) || !isNumber(after.value) || beforeExclusiveMinimum < after.value);\n  },\n  nonBreaking,\n  ({ before, after }) => breakingIf(!isNumber(before.value) || !isNumber(after.value) || before.value < after.value)\n];\nconst maximumClassifier = [\n  ({ before, after }) => {\n    const beforeExclusiveMaximum = getKeyValue(before.parent, \"exclusiveMaximum\");\n    return breakingIf(!isNumber(beforeExclusiveMaximum) || !isNumber(after.value) || beforeExclusiveMaximum > after.value);\n  },\n  nonBreaking,\n  ({ before, after }) => breakingIf(!isNumber(before.value) || !isNumber(after.value) || before.value > after.value)\n];\nconst exclusiveClassifier = [\n  ({ after }) => after.value === true ? breaking : unclassified,\n  ({ before }) => before.value === true ? nonBreaking : unclassified,\n  breakingIfAfterTrue\n];\nconst multipleOfClassifier = [\n  breaking,\n  nonBreaking,\n  ({ before, after }) => breakingIfNotMultiple(before.value, after.value),\n  nonBreaking,\n  breaking,\n  breaking\n];\nconst requiredItemClassifyRule = [\n  ({ after }) => !isString(after.value) || isExist(strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, \"properties\", after.value, \"default\")) ? nonBreaking : breaking,\n  nonBreaking,\n  ({ after }) => !isString(after.value) || isExist(strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, \"properties\", after.value, \"default\")) ? nonBreaking : breaking,\n  nonBreaking,\n  breaking,\n  breaking\n];\nconst propertyClassifyRule = [\n  ({ after }) => {\n    var _a;\n    return !isExist(getKeyValue(after.value, \"default\")) && ((_a = getArrayValue(strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, \"required\"))) == null ? void 0 : _a.includes(after.key)) ? breaking : nonBreaking;\n  },\n  breaking,\n  unclassified,\n  nonBreaking,\n  ({ before }) => {\n    var _a;\n    return ((_a = getArrayValue(strictResolveValueFromContext(before, PARENT_JUMP, PARENT_JUMP, \"required\"))) == null ? void 0 : _a.includes(before.key)) ? breaking : nonBreaking;\n  },\n  unclassified\n];\nconst enumClassifyRule = [\n  ({ before }) => isNotEmptyArray(before.parent) ? nonBreaking : breaking,\n  ({ after }) => isNotEmptyArray(after.parent) ? breaking : nonBreaking,\n  breaking,\n  ({ before }) => isNotEmptyArray(before.parent) ? risky : nonBreaking,\n  ({ after }) => isNotEmptyArray(after.parent) ? nonBreaking : risky,\n  nonBreaking\n];\nconst breakingIfNotMultiple = (num1, num2) => breakingIf(!isNumber(num1) || !isNumber(num2) || num1 % num2 !== 0);\nconst unwrapAnyType = (value, combiner, ctx, nativeAnyFactory) => {\n  var _a, _b;\n  switch (combiner) {\n    case JSON_SCHEMA_PROPERTY_ANY_OF: {\n      return ctx.transformer(value, combiner, (value2) => {\n        return nativeAnyFactory(value2, ctx.valueOrigins, ctx.options);\n      });\n    }\n    case JSON_SCHEMA_PROPERTY_ONE_OF: {\n      (_b = (_a = ctx.options).onUnifyError) == null ? void 0 : _b.call(_a, \"Not Implemented case when anyOf compare with oneOf\", [\"todo\"], value);\n      return value;\n    }\n  }\n};\nconst unwrapNothingType = (value, combiner, ctx) => {\n  return ctx.transformer(value, combiner, (value2) => {\n    const { type, ...copyWithoutType } = value2;\n    copyWithoutType[combiner] = [];\n    copyOrigins(value2, copyWithoutType, JSON_SCHEMA_PROPERTY_TYPE, combiner, ctx.options.originsFlag);\n    cleanOrigins(copyWithoutType, JSON_SCHEMA_PROPERTY_TYPE, ctx.options.originsFlag);\n    return copyWithoutType;\n  });\n};\nconst wrapBySingletonCombiner = (value, combiner, ctx) => {\n  var _a, _b;\n  if (isArray(value)) {\n    (_b = (_a = ctx.options).onUnifyError) == null ? void 0 : _b.call(_a, \"Not Implemented case when anyOf compare with oneOf\", [\"todo\"], value);\n    return value;\n  }\n  return ctx.transformer(value, combiner, (value2) => {\n    const combinerValues = [value2];\n    const valueCopy = { [combiner]: combinerValues };\n    setOrigins(valueCopy, combiner, ctx.options.originsFlag, ctx.valueOrigins);\n    setOrigins(combinerValues, 0, ctx.options.originsFlag, ctx.valueOrigins);\n    return valueCopy;\n  });\n};\nconst jsonSchemaAdapter = (factory) => (value, reference, ctx) => {\n  if (!isObject(value) || !isObject(reference)) {\n    return value;\n  }\n  let newValue = value;\n  const valueContext = ctx;\n  for (const combiner of [JSON_SCHEMA_PROPERTY_ONE_OF, JSON_SCHEMA_PROPERTY_ANY_OF]) {\n    if (!(combiner in newValue) && combiner in reference) {\n      const type = newValue[JSON_SCHEMA_PROPERTY_TYPE];\n      switch (type) {\n        case JSON_SCHEMA_NODE_SYNTHETIC_TYPE_ANY: {\n          newValue = unwrapAnyType(newValue, combiner, valueContext, factory);\n          break;\n        }\n        case JSON_SCHEMA_NODE_SYNTHETIC_TYPE_NOTHING: {\n          newValue = unwrapNothingType(newValue, combiner, valueContext);\n          break;\n        }\n        default:\n          newValue = wrapBySingletonCombiner(newValue, combiner, valueContext);\n          break;\n      }\n    }\n  }\n  return newValue;\n};\nconst jsonSchemaMappingResolver = (before, after, ctx) => {\n  const { added, removed, mapped } = objectMappingResolver(before, after);\n  return { added, removed, mapped };\n};\nconst combinersCompareResolver = (ctx) => {\n  const { before, after, options, scope } = ctx;\n  const { metaKey } = options;\n  if (!before || !after) {\n    return { diffs: [], ownerDiffEntry: void 0, merged: void 0 };\n  }\n  if (!isArray(before.value) || !isArray(after.value)) {\n    const diffEntry = createDiffEntry(ctx, diffFactory.replaced(ctx));\n    return { diffs: [diffEntry.diff], ownerDiffEntry: diffEntry, merged: after.value };\n  }\n  const beforeArrayIndexes = onlyExistedArrayIndexes(before.value);\n  const afterArrayIndexes = onlyExistedArrayIndexes(after.value);\n  const beforeMatchedArrayIndexes = new Set(beforeArrayIndexes);\n  const afterMatchedArrayIndexes = new Set(afterArrayIndexes);\n  const comparedItems = [];\n  const mergedCombinerJsoArray = [];\n  const diffs = /* @__PURE__ */ new Set();\n  const rules = getNodeRules(ctx.rules, ANY_COMBINER_INDEX, ANY_COMBINER_PATH, before.value) || {};\n  for (const i of beforeArrayIndexes) {\n    const beforeCombinerJso = before.value[i];\n    for (const j of afterArrayIndexes) {\n      if (!afterMatchedArrayIndexes.has(j)) {\n        continue;\n      }\n      const afterCombinerJso = after.value[j];\n      const {\n        diffs: localDiffs,\n        merged\n      } = ctx.options.mergedJsoCache.cacheEvaluationResultByFootprint(\n        [beforeCombinerJso, afterCombinerJso, scope],\n        ([beforeCombinerJso2, afterCombinerJso2]) => nestedCompare(beforeCombinerJso2, afterCombinerJso2, {\n          ...options,\n          rules,\n          compareScope: ctx.scope\n        }),\n        { diffs: [], ownerDiffEntry: void 0, merged: {} },\n        (result, guard) => {\n          guard.diffs.push(...result.diffs);\n          if (isObject(guard.merged) && isObject(result.merged))\n            guard.merged = copyDescriptors(guard.merged, result.merged);\n          else\n            guard.merged = result.merged;\n          return guard;\n        }\n      );\n      if (!localDiffs.length) {\n        afterMatchedArrayIndexes.delete(j);\n        beforeMatchedArrayIndexes.delete(i);\n        mergedCombinerJsoArray[j] = merged;\n        break;\n      }\n      comparedItems.push({\n        before: i,\n        after: j,\n        diffs: localDiffs,\n        merged\n      });\n    }\n  }\n  comparedItems.sort((a, b) => {\n    const mainDiff = a.diffs.length - b.diffs.length;\n    return mainDiff !== 0 ? mainDiff : Math.abs(a.before - a.after) - Math.abs(b.before - b.after);\n  });\n  for (const compared of comparedItems) {\n    if (!afterMatchedArrayIndexes.has(compared.after) || !beforeMatchedArrayIndexes.has(compared.before)) {\n      continue;\n    }\n    afterMatchedArrayIndexes.delete(compared.after);\n    beforeMatchedArrayIndexes.delete(compared.before);\n    mergedCombinerJsoArray[compared.after] = compared.merged;\n    compared.diffs.forEach((diff) => diffs.add(diff));\n  }\n  const arrayMetaDiffEntries = [];\n  for (const j of afterMatchedArrayIndexes.values()) {\n    mergedCombinerJsoArray[j] = after.value[j];\n    const childCtx = createChildContext(ctx, j, void 0, j);\n    const diffEntry = getOrCreateChildDiffAdd(options.diffUniquenessCache, childCtx);\n    arrayMetaDiffEntries.push(diffEntry);\n    diffs.add(diffEntry.diff);\n  }\n  const usedIndexesArray = onlyExistedArrayIndexes(mergedCombinerJsoArray);\n  const from = Math.min(0, Math.min(...usedIndexesArray));\n  const to = Math.max(...usedIndexesArray) + beforeArrayIndexes.length;\n  const usedIndexes = new Set(usedIndexesArray);\n  const freeIndexesArray = [];\n  for (let k = from; k <= to; k++) {\n    if (!usedIndexes.has(k)) {\n      freeIndexesArray.push(k);\n    }\n  }\n  for (const i of beforeMatchedArrayIndexes.values()) {\n    const safeInsertIndex = freeIndexesArray.shift();\n    mergedCombinerJsoArray[safeInsertIndex] = before.value[i];\n    const childCtx = createChildContext(ctx, safeInsertIndex, i, void 0);\n    const diffEntry = getOrCreateChildDiffRemove(options.diffUniquenessCache, childCtx);\n    arrayMetaDiffEntries.push(diffEntry);\n    diffs.add(diffEntry.diff);\n  }\n  addDiffObjectToContainer(mergedCombinerJsoArray, metaKey, arrayMetaDiffEntries);\n  return {\n    diffs: [...diffs],\n    ownerDiffEntry: void 0,\n    //actually we don't make deep copy here and create \"way to modify\" original source. But fix not so trivial and performance expansive\n    merged: diffs.size === 0 ? after.value : mergedCombinerJsoArray\n  };\n};\nconst simpleRule$1 = (classify, descriptionTemplate) => ({\n  $: classify,\n  description: diffDescription(descriptionTemplate)\n});\nconst arrayItemsRules = (value, rules) => {\n  return Array.isArray(value) ? {\n    \"/*\": {\n      ...rules,\n      $: allBreaking\n    }\n  } : {\n    ...rules,\n    $: allNonBreaking\n  };\n};\nconst jsonSchemaAnyFactory = (schema, _, opt) => {\n  return normalize(schema, {\n    ...opt,\n    // schema is already normalized, resolveRef is disabled and originsAlreadyDefined is true in order to prevent origins override\n    resolveRef: false,\n    originsAlreadyDefined: true,\n    validate: false,\n    allowNotValidSyntheticChanges: false\n  });\n};\nconst jsonSchemaRules = ({\n  additionalRules,\n  version\n}) => {\n  const rules = {\n    adapter: [\n      jsonSchemaAdapter(jsonSchemaAnyFactory)\n    ],\n    mapping: jsonSchemaMappingResolver,\n    // todo: add descriptionParamCalculator only for jsonScheme\n    \"/title\": simpleRule$1(allAnnotation, resolveSchemaDescriptionTemplates(\"title\")),\n    \"/description\": simpleRule$1(allAnnotation, resolveSchemaDescriptionTemplates(\"description\")),\n    \"/type\": simpleRule$1(typeClassifier, resolveSchemaDescriptionTemplates(\"type\")),\n    \"/multipleOf\": simpleRule$1(multipleOfClassifier, resolveSchemaDescriptionTemplates(\"multipleOf validator\")),\n    \"/maximum\": simpleRule$1(maximumClassifier, resolveSchemaDescriptionTemplates(\"maximum validator\")),\n    \"/minimum\": simpleRule$1(minimumClassifier, resolveSchemaDescriptionTemplates(\"minimum validator\")),\n    ...version === SPEC_TYPE_JSON_SCHEMA_04 ? {\n      \"/exclusiveMaximum\": simpleRule$1(exclusiveClassifier, resolveSchemaDescriptionTemplates(\"exclusiveMaximum validator\")),\n      \"/exclusiveMinimum\": simpleRule$1(exclusiveClassifier, resolveSchemaDescriptionTemplates(\"exclusiveMinimum validator\"))\n    } : {\n      \"/exclusiveMaximum\": simpleRule$1(maxClassifier, resolveSchemaDescriptionTemplates(\"exclusiveMaximum validator\")),\n      \"/exclusiveMinimum\": simpleRule$1(minClassifier, resolveSchemaDescriptionTemplates(\"exclusiveMinimum validator\"))\n    },\n    \"/maxLength\": simpleRule$1(maxClassifier, resolveSchemaDescriptionTemplates(\"maxLength validator\")),\n    \"/minLength\": simpleRule$1(minClassifier, resolveSchemaDescriptionTemplates(\"minLength validator\")),\n    \"/pattern\": simpleRule$1([breaking, nonBreaking, breaking, nonBreaking, breaking, breaking], resolveSchemaDescriptionTemplates(\"pattern validator\")),\n    \"/maxItems\": simpleRule$1(maxClassifier, resolveSchemaDescriptionTemplates(\"maxItems validator\")),\n    \"/minItems\": simpleRule$1(minClassifier, resolveSchemaDescriptionTemplates(\"minItems validator\")),\n    \"/uniqueItems\": simpleRule$1(booleanClassifier, resolveSchemaDescriptionTemplates(\"uniqueItems validator\")),\n    \"/maxProperties\": simpleRule$1(maxClassifier, resolveSchemaDescriptionTemplates(\"maxProperties validator\")),\n    \"/minProperties\": simpleRule$1(minClassifier, resolveSchemaDescriptionTemplates(\"minProperties validator\")),\n    \"/readOnly\": simpleRule$1([...booleanClassifier, ...allNonBreaking], resolveSchemaDescriptionTemplates(\"readOnly status\")),\n    \"/writeOnly\": simpleRule$1([...allNonBreaking, ...allNonBreaking], resolveSchemaDescriptionTemplates(\"writeOnly status\")),\n    \"/deprecated\": simpleRule$1(allDeprecated, resolveSchemaDescriptionTemplates(\"deprecated status\")),\n    \"/required\": {\n      mapping: deepEqualsUniqueItemsArrayMappingResolver,\n      \"/*\": ({ key, value }) => {\n        if (!isNumber(key) || !isString(value)) {\n          return void 0;\n        }\n        return {\n          ...simpleRule$1(requiredItemClassifyRule, resolveSchemaDescriptionTemplates(`required status for property '${value}'`)),\n          ignoreKeyDifference: true\n        };\n      }\n    },\n    \"/format\": simpleRule$1([breaking, nonBreaking, breaking, nonBreaking, breaking, breaking], resolveSchemaDescriptionTemplates(\"format\")),\n    \"/default\": simpleRule$1([nonBreaking, breaking, breaking], resolveSchemaDescriptionTemplates(\"default value\")),\n    \"/enum\": {\n      $: [breaking, nonBreaking, breaking, nonBreaking, risky, nonBreaking],\n      mapping: deepEqualsUniqueItemsArrayMappingResolver,\n      \"/*\": ({ key, value }) => {\n        if (!isNumber(key)) {\n          return void 0;\n        }\n        return {\n          $: enumClassifyRule,\n          description: diffDescription(resolveSchemaDescriptionTemplates(isString(value) || isBoolean(value) || isNumber(value) ? `possible value '${value.toString()}'` : \"some possible value\")),\n          ignoreKeyDifference: true\n        };\n      }\n    },\n    \"/oneOf\": {\n      compare: combinersCompareResolver,\n      \"/*\": ({ key }) => {\n        if (!isNumber(key)) {\n          return void 0;\n        }\n        return {\n          ...rules,\n          $: [nonBreaking, breaking, breaking],\n          description: diffDescription(resolveSchemaDescriptionTemplates(`oneOf[${key.toString()}]`))\n        };\n      }\n    },\n    \"/anyOf\": {\n      compare: combinersCompareResolver,\n      \"/*\": ({ key }) => {\n        if (!isNumber(key)) {\n          return void 0;\n        }\n        return {\n          ...rules,\n          $: [nonBreaking, breaking, breaking],\n          description: diffDescription(resolveSchemaDescriptionTemplates(`anyOf[${key.toString()}]`))\n        };\n      }\n    },\n    \"/allOf\": {\n      //TODO CHECK. This node wil be only if allOf broken!!! do we need merge it?\n      compare: combinersCompareResolver,\n      \"/*\": () => ({\n        ...rules,\n        $: allBreaking\n      })\n    },\n    \"/const\": simpleRule$1([breaking, nonBreaking, breaking], resolveSchemaDescriptionTemplates(\"const\")),\n    \"/not\": () => ({\n      // TODO check\n      ...transformCompareRules(rules, reverseClassifyRuleTransformer),\n      $: allBreaking\n    }),\n    \"/items\": ({ value }) => arrayItemsRules(value, rules),\n    \"/additionalItems\": () => ({\n      ...rules,\n      $: [nonBreaking, breaking, unclassified]\n    }),\n    \"/properties\": {\n      \"/*\": ({ key }) => {\n        if (!isString(key)) {\n          return void 0;\n        }\n        return {\n          ...rules,\n          $: propertyClassifyRule,\n          description: diffDescription(resolveSchemaDescriptionTemplates(`property '${key.toString()}'`))\n        };\n      }\n    },\n    \"/additionalProperties\": () => ({\n      ...rules,\n      $: additionalPropertiesClassifier\n    }),\n    \"/patternProperties\": {\n      \"/*\": () => ({\n        ...rules,\n        $: [breaking, nonBreaking, unclassified]\n      })\n    },\n    \"/propertyNames\": () => ({ ...rules, $: onlyAddBreaking }),\n    // TODO \"/dependencies\": {},\n    \"/definitions\": {\n      \"/*\": () => ({\n        ...rules,\n        $: allNonBreaking\n      })\n    },\n    \"/$defs\": {\n      \"/*\": () => ({\n        ...rules,\n        $: allNonBreaking\n      })\n    },\n    //TODO NOT BY SPECIFICATION. ONLY IN 06 VERSION. NC SPECIFIC EXCLUSION\n    \"/examples\": {\n      $: allAnnotation,\n      \"/*\": { $: allAnnotation }\n    },\n    // unknown tags\n    \"/**\": {\n      $: allUnclassified\n    },\n    ...additionalRules\n  };\n  return rules;\n};\nconst additionalPropertiesClassifier = [\n  breaking,\n  breaking,\n  (ctx) => breakingIf(!!ctx.before.value),\n  breaking,\n  breaking,\n  (ctx) => breakingIf(!!ctx.after.value)\n];\nconst resolveSchemaDescriptionTemplates = (details = `{{${TEMPLATE_PARAM_PROPERTY_NAME}}}`) => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] schema {{${TEMPLATE_PARAM_PLACE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] schema in {{${TEMPLATE_PARAM_SCOPE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} schema in {{${TEMPLATE_PARAM_SCOPE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} schema {{${TEMPLATE_PARAM_PLACE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_SCHEMA_PATH}}}' in {{${TEMPLATE_PARAM_SCOPE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_SCHEMA_PATH}}}' {{${TEMPLATE_PARAM_PLACE}}}`\n];\nconst compareJsonSchema = (version) => (before, after, options) => {\n  return compare(before, after, {\n    ...options,\n    rules: jsonSchemaRules({ version, additionalRules: {} }),\n    compareScope: COMPARE_SCOPE_ROOT,\n    mergedJsoCache: createEvaluationCacheService(),\n    diffUniquenessCache: createEvaluationCacheService(),\n    createdMergedJso: /* @__PURE__ */ new Set()\n  });\n};\nvar DirectiveLocation$1;\n(function(DirectiveLocation2) {\n  DirectiveLocation2[\"QUERY\"] = \"QUERY\";\n  DirectiveLocation2[\"MUTATION\"] = \"MUTATION\";\n  DirectiveLocation2[\"SUBSCRIPTION\"] = \"SUBSCRIPTION\";\n  DirectiveLocation2[\"FIELD\"] = \"FIELD\";\n  DirectiveLocation2[\"FRAGMENT_DEFINITION\"] = \"FRAGMENT_DEFINITION\";\n  DirectiveLocation2[\"FRAGMENT_SPREAD\"] = \"FRAGMENT_SPREAD\";\n  DirectiveLocation2[\"INLINE_FRAGMENT\"] = \"INLINE_FRAGMENT\";\n  DirectiveLocation2[\"VARIABLE_DEFINITION\"] = \"VARIABLE_DEFINITION\";\n  DirectiveLocation2[\"SCHEMA\"] = \"SCHEMA\";\n  DirectiveLocation2[\"SCALAR\"] = \"SCALAR\";\n  DirectiveLocation2[\"OBJECT\"] = \"OBJECT\";\n  DirectiveLocation2[\"FIELD_DEFINITION\"] = \"FIELD_DEFINITION\";\n  DirectiveLocation2[\"ARGUMENT_DEFINITION\"] = \"ARGUMENT_DEFINITION\";\n  DirectiveLocation2[\"INTERFACE\"] = \"INTERFACE\";\n  DirectiveLocation2[\"UNION\"] = \"UNION\";\n  DirectiveLocation2[\"ENUM\"] = \"ENUM\";\n  DirectiveLocation2[\"ENUM_VALUE\"] = \"ENUM_VALUE\";\n  DirectiveLocation2[\"INPUT_OBJECT\"] = \"INPUT_OBJECT\";\n  DirectiveLocation2[\"INPUT_FIELD_DEFINITION\"] = \"INPUT_FIELD_DEFINITION\";\n})(DirectiveLocation$1 || (DirectiveLocation$1 = {}));\nconst COMPARE_SCOPE_OUTPUT = \"output\";\nconst COMPARE_SCOPE_ARGS = \"args\";\nconst COMPARE_SCOPE_COMPONENTS$1 = \"components\";\nconst COMPARE_SCOPE_DIRECTIVE_USAGES = \"directive-usages\";\nconst RUNTIME_DIRECTIVE_LOCATIONS = /* @__PURE__ */ new Set([\n  DirectiveLocation$1.QUERY,\n  DirectiveLocation$1.MUTATION,\n  DirectiveLocation$1.SUBSCRIPTION,\n  DirectiveLocation$1.FIELD,\n  DirectiveLocation$1.FRAGMENT_DEFINITION,\n  DirectiveLocation$1.FRAGMENT_SPREAD,\n  DirectiveLocation$1.INLINE_FRAGMENT,\n  DirectiveLocation$1.VARIABLE_DEFINITION\n]);\nfunction devAssert(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\nfunction isObjectLike(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(\n      \"Unexpected invariant triggered.\"\n    );\n  }\n}\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\nfunction getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === \"number\" || invariant(false);\n    if (match.index >= position) {\n      break;\n    }\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n  return {\n    line,\n    column: position + 1 - lastLineStart\n  };\n}\nfunction printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start)\n  );\n}\nfunction printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = \"\".padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex];\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n    return locationStr + printPrefixedLines([\n      [`${lineNum} |`, subLines[0]],\n      ...subLines.slice(1, subLineIndex + 1).map((subLine) => [\"|\", subLine]),\n      [\"|\", \"^\".padStart(subLineColumnNum)],\n      [\"|\", subLines[subLineIndex + 1]]\n    ]);\n  }\n  return locationStr + printPrefixedLines([\n    // Lines specified like this: [\"prefix\", \"string\"],\n    [`${lineNum - 1} |`, lines[lineIndex - 1]],\n    [`${lineNum} |`, locationLine],\n    [\"|\", \"^\".padStart(columnNum)],\n    [`${lineNum + 1} |`, lines[lineIndex + 1]]\n  ]);\n}\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== void 0);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? \" \" + line : \"\")).join(\"\\n\");\n}\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n  if (firstArg == null || \"kind\" in firstArg || \"length\" in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5]\n    };\n  }\n  return firstArg;\n}\nclass GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n  /**\n   * Extension fields to add to the formatted error.\n   */\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = \"GraphQLError\";\n    this.path = path !== null && path !== void 0 ? path : void 0;\n    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)\n    );\n    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;\n    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);\n    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0 ? void 0 : originalError.extensions\n    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;\n    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true\n      },\n      name: {\n        enumerable: false\n      },\n      nodes: {\n        enumerable: false\n      },\n      source: {\n        enumerable: false\n      },\n      positions: {\n        enumerable: false\n      },\n      originalError: {\n        enumerable: false\n      }\n    });\n    if (originalError !== null && originalError !== void 0 && originalError.stack) {\n      Object.defineProperty(this, \"stack\", {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, \"stack\", {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n  toString() {\n    let output = this.message;\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += \"\\n\\n\" + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += \"\\n\\n\" + printSourceLocation(this.source, location);\n      }\n    }\n    return output;\n  }\n  toJSON() {\n    const formattedError = {\n      message: this.message\n    };\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n    return formattedError;\n  }\n}\nfunction undefinedIfEmpty(array) {\n  return array === void 0 || array.length === 0 ? void 0 : array;\n}\nconst QueryDocumentKeys = {\n  Name: [],\n  Document: [\"definitions\"],\n  OperationDefinition: [\n    \"name\",\n    \"variableDefinitions\",\n    \"directives\",\n    \"selectionSet\"\n  ],\n  VariableDefinition: [\"variable\", \"type\", \"defaultValue\", \"directives\"],\n  Variable: [\"name\"],\n  SelectionSet: [\"selections\"],\n  Field: [\"alias\", \"name\", \"arguments\", \"directives\", \"selectionSet\"],\n  Argument: [\"name\", \"value\"],\n  FragmentSpread: [\"name\", \"directives\"],\n  InlineFragment: [\"typeCondition\", \"directives\", \"selectionSet\"],\n  FragmentDefinition: [\n    \"name\",\n    // Note: fragment variable definitions are deprecated and will removed in v17.0.0\n    \"variableDefinitions\",\n    \"typeCondition\",\n    \"directives\",\n    \"selectionSet\"\n  ],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: [\"values\"],\n  ObjectValue: [\"fields\"],\n  ObjectField: [\"name\", \"value\"],\n  Directive: [\"name\", \"arguments\"],\n  NamedType: [\"name\"],\n  ListType: [\"type\"],\n  NonNullType: [\"type\"],\n  SchemaDefinition: [\"description\", \"directives\", \"operationTypes\"],\n  OperationTypeDefinition: [\"type\"],\n  ScalarTypeDefinition: [\"description\", \"name\", \"directives\"],\n  ObjectTypeDefinition: [\n    \"description\",\n    \"name\",\n    \"interfaces\",\n    \"directives\",\n    \"fields\"\n  ],\n  FieldDefinition: [\"description\", \"name\", \"arguments\", \"type\", \"directives\"],\n  InputValueDefinition: [\n    \"description\",\n    \"name\",\n    \"type\",\n    \"defaultValue\",\n    \"directives\"\n  ],\n  InterfaceTypeDefinition: [\n    \"description\",\n    \"name\",\n    \"interfaces\",\n    \"directives\",\n    \"fields\"\n  ],\n  UnionTypeDefinition: [\"description\", \"name\", \"directives\", \"types\"],\n  EnumTypeDefinition: [\"description\", \"name\", \"directives\", \"values\"],\n  EnumValueDefinition: [\"description\", \"name\", \"directives\"],\n  InputObjectTypeDefinition: [\"description\", \"name\", \"directives\", \"fields\"],\n  DirectiveDefinition: [\"description\", \"name\", \"arguments\", \"locations\"],\n  SchemaExtension: [\"directives\", \"operationTypes\"],\n  ScalarTypeExtension: [\"name\", \"directives\"],\n  ObjectTypeExtension: [\"name\", \"interfaces\", \"directives\", \"fields\"],\n  InterfaceTypeExtension: [\"name\", \"interfaces\", \"directives\", \"fields\"],\n  UnionTypeExtension: [\"name\", \"directives\", \"types\"],\n  EnumTypeExtension: [\"name\", \"directives\", \"values\"],\n  InputObjectTypeExtension: [\"name\", \"directives\", \"fields\"]\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\nfunction isNode(maybeNode) {\n  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === \"string\" && kindValues.has(maybeKind);\n}\nvar OperationTypeNode;\n(function(OperationTypeNode2) {\n  OperationTypeNode2[\"QUERY\"] = \"query\";\n  OperationTypeNode2[\"MUTATION\"] = \"mutation\";\n  OperationTypeNode2[\"SUBSCRIPTION\"] = \"subscription\";\n})(OperationTypeNode || (OperationTypeNode = {}));\nvar DirectiveLocation;\n(function(DirectiveLocation2) {\n  DirectiveLocation2[\"QUERY\"] = \"QUERY\";\n  DirectiveLocation2[\"MUTATION\"] = \"MUTATION\";\n  DirectiveLocation2[\"SUBSCRIPTION\"] = \"SUBSCRIPTION\";\n  DirectiveLocation2[\"FIELD\"] = \"FIELD\";\n  DirectiveLocation2[\"FRAGMENT_DEFINITION\"] = \"FRAGMENT_DEFINITION\";\n  DirectiveLocation2[\"FRAGMENT_SPREAD\"] = \"FRAGMENT_SPREAD\";\n  DirectiveLocation2[\"INLINE_FRAGMENT\"] = \"INLINE_FRAGMENT\";\n  DirectiveLocation2[\"VARIABLE_DEFINITION\"] = \"VARIABLE_DEFINITION\";\n  DirectiveLocation2[\"SCHEMA\"] = \"SCHEMA\";\n  DirectiveLocation2[\"SCALAR\"] = \"SCALAR\";\n  DirectiveLocation2[\"OBJECT\"] = \"OBJECT\";\n  DirectiveLocation2[\"FIELD_DEFINITION\"] = \"FIELD_DEFINITION\";\n  DirectiveLocation2[\"ARGUMENT_DEFINITION\"] = \"ARGUMENT_DEFINITION\";\n  DirectiveLocation2[\"INTERFACE\"] = \"INTERFACE\";\n  DirectiveLocation2[\"UNION\"] = \"UNION\";\n  DirectiveLocation2[\"ENUM\"] = \"ENUM\";\n  DirectiveLocation2[\"ENUM_VALUE\"] = \"ENUM_VALUE\";\n  DirectiveLocation2[\"INPUT_OBJECT\"] = \"INPUT_OBJECT\";\n  DirectiveLocation2[\"INPUT_FIELD_DEFINITION\"] = \"INPUT_FIELD_DEFINITION\";\n})(DirectiveLocation || (DirectiveLocation = {}));\nvar Kind;\n(function(Kind2) {\n  Kind2[\"NAME\"] = \"Name\";\n  Kind2[\"DOCUMENT\"] = \"Document\";\n  Kind2[\"OPERATION_DEFINITION\"] = \"OperationDefinition\";\n  Kind2[\"VARIABLE_DEFINITION\"] = \"VariableDefinition\";\n  Kind2[\"SELECTION_SET\"] = \"SelectionSet\";\n  Kind2[\"FIELD\"] = \"Field\";\n  Kind2[\"ARGUMENT\"] = \"Argument\";\n  Kind2[\"FRAGMENT_SPREAD\"] = \"FragmentSpread\";\n  Kind2[\"INLINE_FRAGMENT\"] = \"InlineFragment\";\n  Kind2[\"FRAGMENT_DEFINITION\"] = \"FragmentDefinition\";\n  Kind2[\"VARIABLE\"] = \"Variable\";\n  Kind2[\"INT\"] = \"IntValue\";\n  Kind2[\"FLOAT\"] = \"FloatValue\";\n  Kind2[\"STRING\"] = \"StringValue\";\n  Kind2[\"BOOLEAN\"] = \"BooleanValue\";\n  Kind2[\"NULL\"] = \"NullValue\";\n  Kind2[\"ENUM\"] = \"EnumValue\";\n  Kind2[\"LIST\"] = \"ListValue\";\n  Kind2[\"OBJECT\"] = \"ObjectValue\";\n  Kind2[\"OBJECT_FIELD\"] = \"ObjectField\";\n  Kind2[\"DIRECTIVE\"] = \"Directive\";\n  Kind2[\"NAMED_TYPE\"] = \"NamedType\";\n  Kind2[\"LIST_TYPE\"] = \"ListType\";\n  Kind2[\"NON_NULL_TYPE\"] = \"NonNullType\";\n  Kind2[\"SCHEMA_DEFINITION\"] = \"SchemaDefinition\";\n  Kind2[\"OPERATION_TYPE_DEFINITION\"] = \"OperationTypeDefinition\";\n  Kind2[\"SCALAR_TYPE_DEFINITION\"] = \"ScalarTypeDefinition\";\n  Kind2[\"OBJECT_TYPE_DEFINITION\"] = \"ObjectTypeDefinition\";\n  Kind2[\"FIELD_DEFINITION\"] = \"FieldDefinition\";\n  Kind2[\"INPUT_VALUE_DEFINITION\"] = \"InputValueDefinition\";\n  Kind2[\"INTERFACE_TYPE_DEFINITION\"] = \"InterfaceTypeDefinition\";\n  Kind2[\"UNION_TYPE_DEFINITION\"] = \"UnionTypeDefinition\";\n  Kind2[\"ENUM_TYPE_DEFINITION\"] = \"EnumTypeDefinition\";\n  Kind2[\"ENUM_VALUE_DEFINITION\"] = \"EnumValueDefinition\";\n  Kind2[\"INPUT_OBJECT_TYPE_DEFINITION\"] = \"InputObjectTypeDefinition\";\n  Kind2[\"DIRECTIVE_DEFINITION\"] = \"DirectiveDefinition\";\n  Kind2[\"SCHEMA_EXTENSION\"] = \"SchemaExtension\";\n  Kind2[\"SCALAR_TYPE_EXTENSION\"] = \"ScalarTypeExtension\";\n  Kind2[\"OBJECT_TYPE_EXTENSION\"] = \"ObjectTypeExtension\";\n  Kind2[\"INTERFACE_TYPE_EXTENSION\"] = \"InterfaceTypeExtension\";\n  Kind2[\"UNION_TYPE_EXTENSION\"] = \"UnionTypeExtension\";\n  Kind2[\"ENUM_TYPE_EXTENSION\"] = \"EnumTypeExtension\";\n  Kind2[\"INPUT_OBJECT_TYPE_EXTENSION\"] = \"InputObjectTypeExtension\";\n})(Kind || (Kind = {}));\nfunction isWhiteSpace(code) {\n  return code === 9 || code === 32;\n}\nfunction isDigit$1(code) {\n  return code >= 48 && code <= 57;\n}\nfunction isLetter(code) {\n  return code >= 97 && code <= 122 || // A-Z\n  code >= 65 && code <= 90;\n}\nfunction isNameStart(code) {\n  return isLetter(code) || code === 95;\n}\nfunction isNameContinue(code) {\n  return isLetter(code) || isDigit$1(code) || code === 95;\n}\nfunction printBlockString(value, options) {\n  const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1;\n  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));\n  const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"');\n  const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith(\"\\\\\");\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines = (\n    // add leading and trailing new lines only if it improves readability\n    !isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes\n  );\n  let result = \"\";\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n    result += \"\\n\";\n  }\n  result += escapedValue;\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += \"\\n\";\n  }\n  return '\"\"\"' + result + '\"\"\"';\n}\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\nfunction inspect(value) {\n  return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case \"string\":\n      return JSON.stringify(value);\n    case \"function\":\n      return value.name ? `[function ${value.name}]` : \"[function]\";\n    case \"object\":\n      return formatObjectValue(value, seenValues);\n    default:\n      return String(value);\n  }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return \"null\";\n  }\n  if (previouslySeenValues.includes(value)) {\n    return \"[Circular]\";\n  }\n  const seenValues = [...previouslySeenValues, value];\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON();\n    if (jsonValue !== value) {\n      return typeof jsonValue === \"string\" ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n  return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n  return typeof value.toJSON === \"function\";\n}\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n  if (entries.length === 0) {\n    return \"{}\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return \"[\" + getObjectTag(object) + \"]\";\n  }\n  const properties = entries.map(\n    ([key, value]) => key + \": \" + formatValue(value, seenValues)\n  );\n  return \"{ \" + properties.join(\", \") + \" }\";\n}\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return \"[]\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return \"[Array]\";\n  }\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n  if (remaining === 1) {\n    items.push(\"... 1 more item\");\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n  return \"[\" + items.join(\", \") + \"]\";\n}\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n  if (tag === \"Object\" && typeof object.constructor === \"function\") {\n    const name = object.constructor.name;\n    if (typeof name === \"string\" && name !== \"\") {\n      return name;\n    }\n  }\n  return tag;\n}\nconst isProduction = globalThis.process && // eslint-disable-next-line no-undef\nprocess.env.NODE_ENV === \"production\";\nconst instanceOf = (\n  /* c8 ignore next 6 */\n  // FIXME: https://github.com/graphql/graphql-js/issues/2317\n  isProduction ? function instanceOf2(value, constructor) {\n    return value instanceof constructor;\n  } : function instanceOf3(value, constructor) {\n    if (value instanceof constructor) {\n      return true;\n    }\n    if (typeof value === \"object\" && value !== null) {\n      var _value$constructor;\n      const className = constructor.prototype[Symbol.toStringTag];\n      const valueClassName = (\n        // We still need to support constructor's name to detect conflicts with older versions of this library.\n        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name\n      );\n      if (className === valueClassName) {\n        const stringifiedValue = inspect(value);\n        throw new Error(`Cannot use ${className} \"${stringifiedValue}\" from another module or realm.\n\nEnsure that there is only one instance of \"graphql\" in the node_modules\ndirectory. If different versions of \"graphql\" are the dependencies of other\nrelied on modules, use \"resolutions\" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate \"graphql\" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.`);\n      }\n    }\n    return false;\n  }\n);\nconst MAX_SUGGESTIONS = 5;\nfunction didYouMean(firstArg, secondArg) {\n  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];\n  let message = \" Did you mean \";\n  if (subMessage) {\n    message += subMessage + \" \";\n  }\n  const suggestions = suggestionsArg.map((x) => `\"${x}\"`);\n  switch (suggestions.length) {\n    case 0:\n      return \"\";\n    case 1:\n      return message + suggestions[0] + \"?\";\n    case 2:\n      return message + suggestions[0] + \" or \" + suggestions[1] + \"?\";\n  }\n  const selected = suggestions.slice(0, MAX_SUGGESTIONS);\n  const lastItem = selected.pop();\n  return message + selected.join(\", \") + \", or \" + lastItem + \"?\";\n}\nfunction identityFunc(x) {\n  return x;\n}\nfunction keyMap(list, keyFn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const item of list) {\n    result[keyFn(item)] = item;\n  }\n  return result;\n}\nfunction keyValMap(list, keyFn, valFn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const item of list) {\n    result[keyFn(item)] = valFn(item);\n  }\n  return result;\n}\nfunction mapValue(map, fn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const key of Object.keys(map)) {\n    result[key] = fn(map[key], key);\n  }\n  return result;\n}\nfunction naturalCompare(aStr, bStr) {\n  let aIndex = 0;\n  let bIndex = 0;\n  while (aIndex < aStr.length && bIndex < bStr.length) {\n    let aChar = aStr.charCodeAt(aIndex);\n    let bChar = bStr.charCodeAt(bIndex);\n    if (isDigit(aChar) && isDigit(bChar)) {\n      let aNum = 0;\n      do {\n        ++aIndex;\n        aNum = aNum * 10 + aChar - DIGIT_0;\n        aChar = aStr.charCodeAt(aIndex);\n      } while (isDigit(aChar) && aNum > 0);\n      let bNum = 0;\n      do {\n        ++bIndex;\n        bNum = bNum * 10 + bChar - DIGIT_0;\n        bChar = bStr.charCodeAt(bIndex);\n      } while (isDigit(bChar) && bNum > 0);\n      if (aNum < bNum) {\n        return -1;\n      }\n      if (aNum > bNum) {\n        return 1;\n      }\n    } else {\n      if (aChar < bChar) {\n        return -1;\n      }\n      if (aChar > bChar) {\n        return 1;\n      }\n      ++aIndex;\n      ++bIndex;\n    }\n  }\n  return aStr.length - bStr.length;\n}\nconst DIGIT_0 = 48;\nconst DIGIT_9 = 57;\nfunction isDigit(code) {\n  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;\n}\nfunction suggestionList(input, options) {\n  const optionsByDistance = /* @__PURE__ */ Object.create(null);\n  const lexicalDistance = new LexicalDistance(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n  for (const option of options) {\n    const distance = lexicalDistance.measure(option, threshold);\n    if (distance !== void 0) {\n      optionsByDistance[option] = distance;\n    }\n  }\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\nclass LexicalDistance {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0)\n    ];\n  }\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n    const optionLowerCase = option.toLowerCase();\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n    let a = stringToArray(optionLowerCase);\n    let b = this._inputArray;\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength - bLength > threshold) {\n      return void 0;\n    }\n    const rows = this._rows;\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = currentRow[0] = i;\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(\n          upRow[j] + 1,\n          // delete\n          currentRow[j - 1] + 1,\n          // insert\n          upRow[j - 1] + cost\n          // substitute\n        );\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n        currentRow[j] = currentCell;\n      }\n      if (smallestCell > threshold) {\n        return void 0;\n      }\n    }\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : void 0;\n  }\n}\nfunction stringToArray(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}\nfunction toObjMap(obj) {\n  if (obj == null) {\n    return /* @__PURE__ */ Object.create(null);\n  }\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of Object.entries(obj)) {\n    map[key] = value;\n  }\n  return map;\n}\nfunction printString$1(str) {\n  return `\"${str.replace(escapedRegExp, escapedReplacer)}\"`;\n}\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\nfunction escapedReplacer(str) {\n  return escapeSequences[str.charCodeAt(0)];\n}\nconst escapeSequences = [\n  \"\\\\u0000\",\n  \"\\\\u0001\",\n  \"\\\\u0002\",\n  \"\\\\u0003\",\n  \"\\\\u0004\",\n  \"\\\\u0005\",\n  \"\\\\u0006\",\n  \"\\\\u0007\",\n  \"\\\\b\",\n  \"\\\\t\",\n  \"\\\\n\",\n  \"\\\\u000B\",\n  \"\\\\f\",\n  \"\\\\r\",\n  \"\\\\u000E\",\n  \"\\\\u000F\",\n  \"\\\\u0010\",\n  \"\\\\u0011\",\n  \"\\\\u0012\",\n  \"\\\\u0013\",\n  \"\\\\u0014\",\n  \"\\\\u0015\",\n  \"\\\\u0016\",\n  \"\\\\u0017\",\n  \"\\\\u0018\",\n  \"\\\\u0019\",\n  \"\\\\u001A\",\n  \"\\\\u001B\",\n  \"\\\\u001C\",\n  \"\\\\u001D\",\n  \"\\\\u001E\",\n  \"\\\\u001F\",\n  \"\",\n  \"\",\n  '\\\\\"',\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  // 2F\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  // 3F\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  // 4F\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\\\\\\",\n  \"\",\n  \"\",\n  \"\",\n  // 5F\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  // 6F\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\u007F\",\n  \"\\\\u0080\",\n  \"\\\\u0081\",\n  \"\\\\u0082\",\n  \"\\\\u0083\",\n  \"\\\\u0084\",\n  \"\\\\u0085\",\n  \"\\\\u0086\",\n  \"\\\\u0087\",\n  \"\\\\u0088\",\n  \"\\\\u0089\",\n  \"\\\\u008A\",\n  \"\\\\u008B\",\n  \"\\\\u008C\",\n  \"\\\\u008D\",\n  \"\\\\u008E\",\n  \"\\\\u008F\",\n  \"\\\\u0090\",\n  \"\\\\u0091\",\n  \"\\\\u0092\",\n  \"\\\\u0093\",\n  \"\\\\u0094\",\n  \"\\\\u0095\",\n  \"\\\\u0096\",\n  \"\\\\u0097\",\n  \"\\\\u0098\",\n  \"\\\\u0099\",\n  \"\\\\u009A\",\n  \"\\\\u009B\",\n  \"\\\\u009C\",\n  \"\\\\u009D\",\n  \"\\\\u009E\",\n  \"\\\\u009F\"\n];\nconst BREAK = Object.freeze({});\nfunction visit(root, visitor, visitorKeys = QueryDocumentKeys) {\n  const enterLeaveMap = /* @__PURE__ */ new Map();\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  let stack = void 0;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = void 0;\n  let parent = void 0;\n  const path = [];\n  const ancestors = [];\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? void 0 : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties(\n            {},\n            Object.getOwnPropertyDescriptors(node)\n          );\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === null || node === void 0) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n      if (result === BREAK) {\n        break;\n      }\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== void 0) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === void 0 && isEdited) {\n      edits.push([key, node]);\n    }\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== void 0);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1];\n  }\n  return root;\n}\nfunction getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n  if (typeof kindVisitor === \"object\") {\n    return kindVisitor;\n  } else if (typeof kindVisitor === \"function\") {\n    return {\n      enter: kindVisitor,\n      leave: void 0\n    };\n  }\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave\n  };\n}\nfunction print(ast) {\n  return visit(ast, printDocASTReducer);\n}\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: (node) => node.value\n  },\n  Variable: {\n    leave: (node) => \"$\" + node.name\n  },\n  // Document\n  Document: {\n    leave: (node) => join(node.definitions, \"\\n\\n\")\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap(\"(\", join(node.variableDefinitions, \", \"), \")\");\n      const prefix = join(\n        [\n          node.operation,\n          join([node.name, varDefs]),\n          join(node.directives, \" \")\n        ],\n        \" \"\n      );\n      return (prefix === \"query\" ? \"\" : prefix + \" \") + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: ({ variable, type, defaultValue, directives }) => variable + \": \" + type + wrap(\" = \", defaultValue) + wrap(\" \", join(directives, \" \"))\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block(selections)\n  },\n  Field: {\n    leave({ alias, name, arguments: args, directives, selectionSet }) {\n      const prefix = wrap(\"\", alias, \": \") + name;\n      let argsLine = prefix + wrap(\"(\", join(args, \", \"), \")\");\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\");\n      }\n      return join([argsLine, join(directives, \" \"), selectionSet], \" \");\n    }\n  },\n  Argument: {\n    leave: ({ name, value }) => name + \": \" + value\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: ({ name, directives }) => \"...\" + name + wrap(\" \", join(directives, \" \"))\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) => join(\n      [\n        \"...\",\n        wrap(\"on \", typeCondition),\n        join(directives, \" \"),\n        selectionSet\n      ],\n      \" \"\n    )\n  },\n  FragmentDefinition: {\n    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (\n      // or removed in the future.\n      `fragment ${name}${wrap(\"(\", join(variableDefinitions, \", \"), \")\")} on ${typeCondition} ${wrap(\"\", join(directives, \" \"), \" \")}` + selectionSet\n    )\n  },\n  // Value\n  IntValue: {\n    leave: ({ value }) => value\n  },\n  FloatValue: {\n    leave: ({ value }) => value\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString$1(value)\n  },\n  BooleanValue: {\n    leave: ({ value }) => value ? \"true\" : \"false\"\n  },\n  NullValue: {\n    leave: () => \"null\"\n  },\n  EnumValue: {\n    leave: ({ value }) => value\n  },\n  ListValue: {\n    leave: ({ values }) => \"[\" + join(values, \", \") + \"]\"\n  },\n  ObjectValue: {\n    leave: ({ fields }) => \"{\" + join(fields, \", \") + \"}\"\n  },\n  ObjectField: {\n    leave: ({ name, value }) => name + \": \" + value\n  },\n  // Directive\n  Directive: {\n    leave: ({ name, arguments: args }) => \"@\" + name + wrap(\"(\", join(args, \", \"), \")\")\n  },\n  // Type\n  NamedType: {\n    leave: ({ name }) => name\n  },\n  ListType: {\n    leave: ({ type }) => \"[\" + type + \"]\"\n  },\n  NonNullType: {\n    leave: ({ type }) => type + \"!\"\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) => wrap(\"\", description, \"\\n\") + join([\"schema\", join(directives, \" \"), block(operationTypes)], \" \")\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type }) => operation + \": \" + type\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name, directives }) => wrap(\"\", description, \"\\n\") + join([\"scalar\", name, join(directives, \" \")], \" \")\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) => wrap(\"\", description, \"\\n\") + join(\n      [\n        \"type\",\n        name,\n        wrap(\"implements \", join(interfaces, \" & \")),\n        join(directives, \" \"),\n        block(fields)\n      ],\n      \" \"\n    )\n  },\n  FieldDefinition: {\n    leave: ({ description, name, arguments: args, type, directives }) => wrap(\"\", description, \"\\n\") + name + (hasMultilineItems(args) ? wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + \": \" + type + wrap(\" \", join(directives, \" \"))\n  },\n  InputValueDefinition: {\n    leave: ({ description, name, type, defaultValue, directives }) => wrap(\"\", description, \"\\n\") + join(\n      [name + \": \" + type, wrap(\"= \", defaultValue), join(directives, \" \")],\n      \" \"\n    )\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) => wrap(\"\", description, \"\\n\") + join(\n      [\n        \"interface\",\n        name,\n        wrap(\"implements \", join(interfaces, \" & \")),\n        join(directives, \" \"),\n        block(fields)\n      ],\n      \" \"\n    )\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name, directives, types }) => wrap(\"\", description, \"\\n\") + join(\n      [\"union\", name, join(directives, \" \"), wrap(\"= \", join(types, \" | \"))],\n      \" \"\n    )\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name, directives, values }) => wrap(\"\", description, \"\\n\") + join([\"enum\", name, join(directives, \" \"), block(values)], \" \")\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name, directives }) => wrap(\"\", description, \"\\n\") + join([name, join(directives, \" \")], \" \")\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name, directives, fields }) => wrap(\"\", description, \"\\n\") + join([\"input\", name, join(directives, \" \"), block(fields)], \" \")\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap(\"\", description, \"\\n\") + \"directive @\" + name + (hasMultilineItems(args) ? wrap(\"(\\n\", indent(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + (repeatable ? \" repeatable\" : \"\") + \" on \" + join(locations, \" | \")\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) => join(\n      [\"extend schema\", join(directives, \" \"), block(operationTypes)],\n      \" \"\n    )\n  },\n  ScalarTypeExtension: {\n    leave: ({ name, directives }) => join([\"extend scalar\", name, join(directives, \" \")], \" \")\n  },\n  ObjectTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) => join(\n      [\n        \"extend type\",\n        name,\n        wrap(\"implements \", join(interfaces, \" & \")),\n        join(directives, \" \"),\n        block(fields)\n      ],\n      \" \"\n    )\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) => join(\n      [\n        \"extend interface\",\n        name,\n        wrap(\"implements \", join(interfaces, \" & \")),\n        join(directives, \" \"),\n        block(fields)\n      ],\n      \" \"\n    )\n  },\n  UnionTypeExtension: {\n    leave: ({ name, directives, types }) => join(\n      [\n        \"extend union\",\n        name,\n        join(directives, \" \"),\n        wrap(\"= \", join(types, \" | \"))\n      ],\n      \" \"\n    )\n  },\n  EnumTypeExtension: {\n    leave: ({ name, directives, values }) => join([\"extend enum\", name, join(directives, \" \"), block(values)], \" \")\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name, directives, fields }) => join([\"extend input\", name, join(directives, \" \"), block(fields)], \" \")\n  }\n};\nfunction join(maybeArray, separator = \"\") {\n  var _maybeArray$filter$jo;\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : \"\";\n}\nfunction block(array) {\n  return wrap(\"{\\n\", indent(join(array, \"\\n\")), \"\\n}\");\n}\nfunction wrap(start, maybeString, end = \"\") {\n  return maybeString != null && maybeString !== \"\" ? start + maybeString + end : \"\";\n}\nfunction indent(str) {\n  return wrap(\"  \", str.replace(/\\n/g, \"\\n  \"));\n}\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes(\"\\n\"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}\nfunction valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map(\n        (node) => valueFromASTUntyped(node, variables)\n      );\n    case Kind.OBJECT:\n      return keyValMap(\n        valueNode.fields,\n        (field) => field.name.value,\n        (field) => valueFromASTUntyped(field.value, variables)\n      );\n    case Kind.VARIABLE:\n      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];\n  }\n}\nfunction assertName(name) {\n  name != null || devAssert(false, \"Must provide name.\");\n  typeof name === \"string\" || devAssert(false, \"Expected name to be a string.\");\n  if (name.length === 0) {\n    throw new GraphQLError(\"Expected name to be a non-empty string.\");\n  }\n  for (let i = 1; i < name.length; ++i) {\n    if (!isNameContinue(name.charCodeAt(i))) {\n      throw new GraphQLError(\n        `Names must only contain [_a-zA-Z0-9] but \"${name}\" does not.`\n      );\n    }\n  }\n  if (!isNameStart(name.charCodeAt(0))) {\n    throw new GraphQLError(\n      `Names must start with [_a-zA-Z] but \"${name}\" does not.`\n    );\n  }\n  return name;\n}\nfunction assertEnumValueName(name) {\n  if (name === \"true\" || name === \"false\" || name === \"null\") {\n    throw new GraphQLError(`Enum values cannot be named: ${name}`);\n  }\n  return assertName(name);\n}\nfunction isType(type) {\n  return isScalarType$1(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType$1(type) || isNonNullType$1(type);\n}\nfunction isScalarType$1(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nfunction isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nfunction isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nfunction isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nfunction isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nfunction isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nfunction isListType$1(type) {\n  return instanceOf(type, GraphQLList);\n}\nfunction isNonNullType$1(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nclass GraphQLList {\n  constructor(ofType) {\n    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLList\";\n  }\n  toString() {\n    return \"[\" + String(this.ofType) + \"]\";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) || devAssert(\n      false,\n      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`\n    );\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLNonNull\";\n  }\n  toString() {\n    return String(this.ofType) + \"!\";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction isNullableType(type) {\n  return isType(type) && !isNonNullType$1(type);\n}\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === \"function\" ? thunk() : thunk;\n}\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === \"function\" ? thunk() : thunk;\n}\nclass GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;\n    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    config.specifiedByURL == null || typeof config.specifiedByURL === \"string\" || devAssert(\n      false,\n      `${this.name} must provide \"specifiedByURL\" as a string, but got: ${inspect(config.specifiedByURL)}.`\n    );\n    config.serialize == null || typeof config.serialize === \"function\" || devAssert(\n      false,\n      `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`\n    );\n    if (config.parseLiteral) {\n      typeof config.parseValue === \"function\" && typeof config.parseLiteral === \"function\" || devAssert(\n        false,\n        `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`\n      );\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLScalarType\";\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];\n    this._fields = () => defineFieldMap(config);\n    this._interfaces = () => defineInterfaces(config);\n    config.isTypeOf == null || typeof config.isTypeOf === \"function\" || devAssert(\n      false,\n      `${this.name} must provide \"isTypeOf\" as a function, but got: ${inspect(config.isTypeOf)}.`\n    );\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLObjectType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === \"function\") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n  const interfaces = resolveReadonlyArrayThunk(\n    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []\n  );\n  Array.isArray(interfaces) || devAssert(\n    false,\n    `${config.name} interfaces must be an Array or a function which returns an Array.`\n  );\n  return interfaces;\n}\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(\n    false,\n    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`\n  );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n    isPlainObj(fieldConfig) || devAssert(\n      false,\n      `${config.name}.${fieldName} field config must be an object.`\n    );\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === \"function\" || devAssert(\n      false,\n      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`\n    );\n    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert(\n      false,\n      `${config.name}.${fieldName} args must be an object with argument names as keys.`\n    );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\nfunction defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode\n  }));\n}\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  }));\n}\nfunction argsToArgsConfig(args) {\n  return keyValMap(\n    args,\n    (arg) => arg.name,\n    (arg) => ({\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    })\n  );\n}\nclass GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];\n    this._fields = defineFieldMap.bind(void 0, config);\n    this._interfaces = defineInterfaces.bind(void 0, config);\n    config.resolveType == null || typeof config.resolveType === \"function\" || devAssert(\n      false,\n      `${this.name} must provide \"resolveType\" as a function, but got: ${inspect(config.resolveType)}.`\n    );\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLInterfaceType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === \"function\") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];\n    this._types = defineTypes.bind(void 0, config);\n    config.resolveType == null || typeof config.resolveType === \"function\" || devAssert(\n      false,\n      `${this.name} must provide \"resolveType\" as a function, but got: ${inspect(config.resolveType)}.`\n    );\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLUnionType\";\n  }\n  getTypes() {\n    if (typeof this._types === \"function\") {\n      this._types = this._types();\n    }\n    return this._types;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) || devAssert(\n    false,\n    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`\n  );\n  return types;\n}\nclass GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];\n    this._values = typeof config.values === \"function\" ? config.values : defineEnumValues(this.name, config.values);\n    this._valueLookup = null;\n    this._nameLookup = null;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLEnumType\";\n  }\n  getValues() {\n    if (typeof this._values === \"function\") {\n      this._values = defineEnumValues(this.name, this._values());\n    }\n    return this._values;\n  }\n  getValue(name) {\n    if (this._nameLookup === null) {\n      this._nameLookup = keyMap(this.getValues(), (value) => value.name);\n    }\n    return this._nameLookup[name];\n  }\n  serialize(outputValue) {\n    if (this._valueLookup === null) {\n      this._valueLookup = new Map(\n        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])\n      );\n    }\n    const enumValue = this._valueLookup.get(outputValue);\n    if (enumValue === void 0) {\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`\n      );\n    }\n    return enumValue.name;\n  }\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"string\") {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)\n      );\n    }\n    const enumValue = this.getValue(inputValue);\n    if (enumValue == null) {\n      throw new GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, inputValue)\n      );\n    }\n    return enumValue.value;\n  }\n  parseLiteral(valueNode, _variables) {\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    const enumValue = this.getValue(valueNode.value);\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    return enumValue.value;\n  }\n  toConfig() {\n    const values = keyValMap(\n      this.getValues(),\n      (value) => value.name,\n      (value) => ({\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      })\n    );\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean(\"the enum value\", suggestedValues);\n}\nfunction defineEnumValues(typeName2, valueMap) {\n  isPlainObj(valueMap) || devAssert(\n    false,\n    `${typeName2} values must be an object with value names as keys.`\n  );\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) || devAssert(\n      false,\n      `${typeName2}.${valueName} must refer to an object with a \"value\" key representing an internal value but got: ${inspect(valueConfig)}.`\n    );\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\nclass GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6, _config$isOneOf;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];\n    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;\n    this._fields = defineInputFieldMap.bind(void 0, config);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLInputObjectType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  toConfig() {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      isOneOf: this.isOneOf\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(\n    false,\n    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`\n  );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !(\"resolve\" in fieldConfig) || devAssert(\n      false,\n      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`\n    );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\nconst GRAPHQL_MAX_INT = 2147483647;\nconst GRAPHQL_MIN_INT = -2147483648;\nnew GraphQLScalarType({\n  name: \"Int\",\n  description: \"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? 1 : 0;\n    }\n    let num = coercedValue;\n    if (typeof coercedValue === \"string\" && coercedValue !== \"\") {\n      num = Number(coercedValue);\n    }\n    if (typeof num !== \"number\" || !Number.isInteger(num)) {\n      throw new GraphQLError(\n        `Int cannot represent non-integer value: ${inspect(coercedValue)}`\n      );\n    }\n    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(\n        \"Int cannot represent non 32-bit signed integer value: \" + inspect(coercedValue)\n      );\n    }\n    return num;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"number\" || !Number.isInteger(inputValue)) {\n      throw new GraphQLError(\n        `Int cannot represent non-integer value: ${inspect(inputValue)}`\n      );\n    }\n    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(\n        `Int cannot represent non 32-bit signed integer value: ${inputValue}`\n      );\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(\n        `Int cannot represent non-integer value: ${print(valueNode)}`,\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    const num = parseInt(valueNode.value, 10);\n    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(\n        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    return num;\n  }\n});\nnew GraphQLScalarType({\n  name: \"Float\",\n  description: \"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? 1 : 0;\n    }\n    let num = coercedValue;\n    if (typeof coercedValue === \"string\" && coercedValue !== \"\") {\n      num = Number(coercedValue);\n    }\n    if (typeof num !== \"number\" || !Number.isFinite(num)) {\n      throw new GraphQLError(\n        `Float cannot represent non numeric value: ${inspect(coercedValue)}`\n      );\n    }\n    return num;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"number\" || !Number.isFinite(inputValue)) {\n      throw new GraphQLError(\n        `Float cannot represent non numeric value: ${inspect(inputValue)}`\n      );\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(\n        `Float cannot represent non numeric value: ${print(valueNode)}`,\n        valueNode\n      );\n    }\n    return parseFloat(valueNode.value);\n  }\n});\nconst GraphQLString = new GraphQLScalarType({\n  name: \"String\",\n  description: \"The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"string\") {\n      return coercedValue;\n    }\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? \"true\" : \"false\";\n    }\n    if (typeof coercedValue === \"number\" && Number.isFinite(coercedValue)) {\n      return coercedValue.toString();\n    }\n    throw new GraphQLError(\n      `String cannot represent value: ${inspect(outputValue)}`\n    );\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"string\") {\n      throw new GraphQLError(\n        `String cannot represent a non string value: ${inspect(inputValue)}`\n      );\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING) {\n      throw new GraphQLError(\n        `String cannot represent a non string value: ${print(valueNode)}`,\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    return valueNode.value;\n  }\n});\nconst GraphQLBoolean = new GraphQLScalarType({\n  name: \"Boolean\",\n  description: \"The `Boolean` scalar type represents `true` or `false`.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue;\n    }\n    if (Number.isFinite(coercedValue)) {\n      return coercedValue !== 0;\n    }\n    throw new GraphQLError(\n      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`\n    );\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"boolean\") {\n      throw new GraphQLError(\n        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`\n      );\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.BOOLEAN) {\n      throw new GraphQLError(\n        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    return valueNode.value;\n  }\n});\nnew GraphQLScalarType({\n  name: \"ID\",\n  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.',\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"string\") {\n      return coercedValue;\n    }\n    if (Number.isInteger(coercedValue)) {\n      return String(coercedValue);\n    }\n    throw new GraphQLError(\n      `ID cannot represent value: ${inspect(outputValue)}`\n    );\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue === \"string\") {\n      return inputValue;\n    }\n    if (typeof inputValue === \"number\" && Number.isInteger(inputValue)) {\n      return inputValue.toString();\n    }\n    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(\n        \"ID cannot represent a non-string and non-integer value: \" + print(valueNode),\n        {\n          nodes: valueNode\n        }\n      );\n    }\n    return valueNode.value;\n  }\n});\nfunction serializeObject(outputValue) {\n  if (isObjectLike(outputValue)) {\n    if (typeof outputValue.valueOf === \"function\") {\n      const valueOfResult = outputValue.valueOf();\n      if (!isObjectLike(valueOfResult)) {\n        return valueOfResult;\n      }\n    }\n    if (typeof outputValue.toJSON === \"function\") {\n      return outputValue.toJSON();\n    }\n  }\n  return outputValue;\n}\nclass GraphQLDirective {\n  constructor(config) {\n    var _config$isRepeatable, _config$args;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.locations = config.locations;\n    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);\n    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};\n    isObjectLike(args) && !Array.isArray(args) || devAssert(\n      false,\n      `@${config.name} args must be an object with argument names as keys.`\n    );\n    this.args = defineArguments(args);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLDirective\";\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      locations: this.locations,\n      args: argsToArgsConfig(this.args),\n      isRepeatable: this.isRepeatable,\n      extensions: this.extensions,\n      astNode: this.astNode\n    };\n  }\n  toString() {\n    return \"@\" + this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nnew GraphQLDirective({\n  name: \"include\",\n  description: \"Directs the executor to include this field or fragment only when the `if` argument is true.\",\n  locations: [\n    DirectiveLocation.FIELD,\n    DirectiveLocation.FRAGMENT_SPREAD,\n    DirectiveLocation.INLINE_FRAGMENT\n  ],\n  args: {\n    if: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      description: \"Included when true.\"\n    }\n  }\n});\nnew GraphQLDirective({\n  name: \"skip\",\n  description: \"Directs the executor to skip this field or fragment when the `if` argument is true.\",\n  locations: [\n    DirectiveLocation.FIELD,\n    DirectiveLocation.FRAGMENT_SPREAD,\n    DirectiveLocation.INLINE_FRAGMENT\n  ],\n  args: {\n    if: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      description: \"Skipped when true.\"\n    }\n  }\n});\nconst DEFAULT_DEPRECATION_REASON = \"No longer supported\";\nnew GraphQLDirective({\n  name: \"deprecated\",\n  description: \"Marks an element of a GraphQL schema as no longer supported.\",\n  locations: [\n    DirectiveLocation.FIELD_DEFINITION,\n    DirectiveLocation.ARGUMENT_DEFINITION,\n    DirectiveLocation.INPUT_FIELD_DEFINITION,\n    DirectiveLocation.ENUM_VALUE\n  ],\n  args: {\n    reason: {\n      type: GraphQLString,\n      description: \"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).\",\n      defaultValue: DEFAULT_DEPRECATION_REASON\n    }\n  }\n});\nnew GraphQLDirective({\n  name: \"specifiedBy\",\n  description: \"Exposes a URL that specifies the behavior of this scalar.\",\n  locations: [DirectiveLocation.SCALAR],\n  args: {\n    url: {\n      type: new GraphQLNonNull(GraphQLString),\n      description: \"The URL that specifies the behavior of this scalar.\"\n    }\n  }\n});\nnew GraphQLDirective({\n  name: \"oneOf\",\n  description: \"Indicates exactly one field must be supplied and this field must not be `null`.\",\n  locations: [DirectiveLocation.INPUT_OBJECT],\n  args: {}\n});\nconst GRAPH_API_NODE_KIND_UNION = \"union\";\n[\n  /** Request Definitions */\n  DirectiveLocation.QUERY,\n  DirectiveLocation.MUTATION,\n  DirectiveLocation.SUBSCRIPTION,\n  DirectiveLocation.FIELD,\n  DirectiveLocation.FRAGMENT_DEFINITION,\n  DirectiveLocation.FRAGMENT_SPREAD,\n  DirectiveLocation.INLINE_FRAGMENT,\n  DirectiveLocation.VARIABLE_DEFINITION,\n  /** Type System Definitions */\n  DirectiveLocation.SCHEMA,\n  DirectiveLocation.SCALAR,\n  DirectiveLocation.OBJECT,\n  DirectiveLocation.FIELD_DEFINITION,\n  DirectiveLocation.ARGUMENT_DEFINITION,\n  DirectiveLocation.INTERFACE,\n  DirectiveLocation.UNION,\n  DirectiveLocation.ENUM,\n  DirectiveLocation.ENUM_VALUE,\n  DirectiveLocation.INPUT_OBJECT,\n  DirectiveLocation.INPUT_FIELD_DEFINITION\n];\nconst BUILT_IN_DIRECTIVE_SPECIFIED_BY = \"specifiedBy\";\nconst BUILT_IN_DIRECTIVE_SKIP = \"skip\";\nconst BUILT_IN_DIRECTIVE_INCLUDE = \"include\";\nconst BUILT_IN_DIRECTIVE_DEPRECATED = \"deprecated\";\nconst BUILT_IN_DIRECTIVE_ONE_OF = \"oneOf\";\nconst BUILT_IN_DIRECTIVES = [\n  BUILT_IN_DIRECTIVE_INCLUDE,\n  BUILT_IN_DIRECTIVE_SKIP,\n  BUILT_IN_DIRECTIVE_SPECIFIED_BY,\n  BUILT_IN_DIRECTIVE_DEPRECATED,\n  BUILT_IN_DIRECTIVE_ONE_OF\n];\nnew Set(BUILT_IN_DIRECTIVES);\nconst wrapBySingletonUnion = (value, ctx) => {\n  return ctx.transformer(value, GRAPH_API_PROPERTY_ONE_OF, (value2) => {\n    const combinerValues = [value2];\n    const wrap2 = {\n      [GRAPH_API_PROPERTY_DIRECTIVES]: {},\n      ...value2[GRAPH_API_PROPERTY_TITLE] ? { [GRAPH_API_PROPERTY_TITLE]: value2[GRAPH_API_PROPERTY_TITLE] } : {},\n      [GRAPH_API_PROPERTY_TYPE]: {\n        [GRAPH_API_PROPERTY_KIND]: GRAPH_API_NODE_KIND_UNION,\n        [GRAPH_API_PROPERTY_ONE_OF]: combinerValues,\n        [ctx.options.originsFlag]: {\n          [GRAPH_API_PROPERTY_KIND]: ctx.valueOrigins,\n          [GRAPH_API_PROPERTY_ONE_OF]: ctx.valueOrigins\n        }\n      }\n    };\n    setOrigins(combinerValues, 0, ctx.options.originsFlag, ctx.valueOrigins);\n    if (value2[GRAPH_API_PROPERTY_TITLE])\n      copyOrigins(value2, wrap2, GRAPH_API_PROPERTY_TITLE, GRAPH_API_PROPERTY_TITLE, ctx.options.originsFlag);\n    copyOrigins(value2, wrap2, GRAPH_API_PROPERTY_TYPE, GRAPH_API_PROPERTY_TYPE, ctx.options.originsFlag);\n    return wrap2;\n  });\n};\nconst isRuntimeDirectiveLocations = (value) => {\n  return isArray$1(value) && value.some((location) => RUNTIME_DIRECTIVE_LOCATIONS.has(location));\n};\nconst graphApiSchemaAdapter = (value, reference, ctx) => {\n  if (!isObject(value) || !isObject(reference)) {\n    return value;\n  }\n  let newValue = value;\n  const valueContext = ctx;\n  const { type: valueType } = newValue;\n  const { type: referenceType } = reference;\n  if (!isObject(valueType) || !isObject(referenceType)) {\n    return value;\n  }\n  const { kind: valueKind } = valueType;\n  const { kind: referenceKind } = referenceType;\n  if (valueKind !== referenceKind && referenceKind === GRAPH_API_NODE_KIND_UNION) {\n    newValue = wrapBySingletonUnion(newValue, valueContext);\n  }\n  return newValue;\n};\nconst removeNotCorrectlySupportedInterfacesAdapter = (value, _, ctx) => {\n  if (!isArray$1(value)) {\n    return value;\n  }\n  return ctx.transformer(value, \"to-empty-array\", () => []);\n};\nconst complexTypeCompareResolver = (ctx) => {\n  const { before, after } = ctx;\n  const beforeValue = before.value;\n  const afterValue = after.value;\n  if (!isObject(beforeValue) || !isObject(afterValue) || !isString(beforeValue.kind) || !isString(afterValue.kind)) {\n    const diffEntry2 = createDiffEntry(ctx, diffFactory.replaced(ctx));\n    return { diffs: [diffEntry2.diff], ownerDiffEntry: diffEntry2, merged: after.value };\n  }\n  if (beforeValue.kind === afterValue.kind) {\n    return void 0;\n  }\n  const diffEntry = createDiffEntry(ctx, diffFactory.replaced(ctx));\n  return { diffs: [diffEntry.diff], ownerDiffEntry: diffEntry, merged: after.value };\n};\nconst titleBaseUniqueItemsArrayMappingResolver = customUniqueItemsArrayMappingResolver(\n  (one, another) => isObject$1(one) && isObject$1(another) && GRAPH_API_PROPERTY_TITLE in one && GRAPH_API_PROPERTY_TITLE in another && one[GRAPH_API_PROPERTY_TITLE] === another[GRAPH_API_PROPERTY_TITLE]\n);\nconst nullableClassifier = [\n  unclassified,\n  unclassified,\n  ({ after, scope }) => {\n    const changedNullabilityValue = !!after.value;\n    const willHaveDefault = strictResolveValueFromContext(after, PARENT_JUMP, GRAPH_API_PROPERTY_DEFAULT) !== void 0;\n    if (changedNullabilityValue) {\n      switch (scope) {\n        case COMPARE_SCOPE_OUTPUT:\n          return breaking;\n        case COMPARE_SCOPE_ARGS:\n          return nonBreaking;\n      }\n    } else {\n      switch (scope) {\n        case COMPARE_SCOPE_OUTPUT:\n          return nonBreaking;\n        case COMPARE_SCOPE_ARGS:\n          return breakingIf(!willHaveDefault);\n      }\n    }\n    return unclassified;\n  }\n];\nconst defaultClassifier = [\n  ({ before, after }) => {\n    const possibleDirectiveLocations = optionalResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_LOCATIONS);\n    const argumentWasOptional = !!strictResolveValueFromContext(before, PARENT_JUMP, GRAPH_API_PROPERTY_NULLABLE);\n    if (possibleDirectiveLocations) {\n      if (isRuntimeDirectiveLocations(possibleDirectiveLocations)) {\n        return argumentWasOptional ? unclassified : nonBreaking;\n      } else {\n        return nonBreaking;\n      }\n    } else {\n      return breakingIf(argumentWasOptional);\n    }\n  },\n  ({ before, after }) => {\n    const possibleDirectiveLocations = optionalResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_LOCATIONS);\n    const argumentWasOptional = !!strictResolveValueFromContext(before, PARENT_JUMP, GRAPH_API_PROPERTY_NULLABLE);\n    if (possibleDirectiveLocations) {\n      if (isRuntimeDirectiveLocations(possibleDirectiveLocations)) {\n        return argumentWasOptional ? unclassified : nonBreaking;\n      } else {\n        return nonBreaking;\n      }\n    } else {\n      return breakingIf(argumentWasOptional);\n    }\n  },\n  ({ before, after }) => {\n    {\n      const possibleDirectiveLocations = optionalResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_LOCATIONS);\n      const argumentWasOptional = !!strictResolveValueFromContext(before, PARENT_JUMP, GRAPH_API_PROPERTY_NULLABLE);\n      if (possibleDirectiveLocations) {\n        if (isRuntimeDirectiveLocations(possibleDirectiveLocations)) {\n          return argumentWasOptional ? unclassified : nonBreaking;\n        } else {\n          return nonBreaking;\n        }\n      } else {\n        return breakingIf(argumentWasOptional);\n      }\n    }\n  }\n];\nconst directiveUsageClassifier = [\n  ({ mergeKey }) => {\n    if (mergeKey === BUILT_IN_DIRECTIVE_DEPRECATED) {\n      return deprecated;\n    }\n    if (mergeKey === BUILT_IN_DIRECTIVE_SPECIFIED_BY) {\n      return annotation;\n    }\n    return unclassified;\n  },\n  ({ mergeKey }) => {\n    if (mergeKey === BUILT_IN_DIRECTIVE_DEPRECATED) {\n      return deprecated;\n    }\n    if (mergeKey === BUILT_IN_DIRECTIVE_SPECIFIED_BY) {\n      return annotation;\n    }\n    return unclassified;\n  },\n  unclassified\n];\nconst directiveMetaClassifier = [\n  ({ after }) => {\n    const directiveLocations = strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_DEFINITION, GRAPH_API_PROPERTY_LOCATIONS);\n    if (isRuntimeDirectiveLocations(directiveLocations)) {\n      return unclassified;\n    }\n    return annotation;\n  },\n  ({ before }) => {\n    const directiveLocations = strictResolveValueFromContext(before, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_DEFINITION, GRAPH_API_PROPERTY_LOCATIONS);\n    if (isRuntimeDirectiveLocations(directiveLocations)) {\n      return unclassified;\n    }\n    return annotation;\n  },\n  ({ after, before }) => {\n    const oldDirectiveLocations = strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_DEFINITION, GRAPH_API_PROPERTY_LOCATIONS);\n    const newDirectiveLocations = strictResolveValueFromContext(before, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_DEFINITION, GRAPH_API_PROPERTY_LOCATIONS);\n    if (isRuntimeDirectiveLocations(oldDirectiveLocations) || isRuntimeDirectiveLocations(newDirectiveLocations)) {\n      return unclassified;\n    }\n    return annotation;\n  }\n];\nconst directiveDefinitionClassifier = [\n  nonBreaking,\n  ({ before }) => {\n    const directiveLocations = strictResolveValueFromContext(before, GRAPH_API_PROPERTY_LOCATIONS);\n    if (isRuntimeDirectiveLocations(directiveLocations)) {\n      return breaking;\n    }\n    return nonBreaking;\n  },\n  unclassified\n];\nconst directiveArgumentsClassifier = [\n  ({ after }) => {\n    const isRuntimeDirective = isRuntimeDirectiveLocations(strictResolveValueFromContext(after, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_LOCATIONS));\n    if (isRuntimeDirective) {\n      const argumentWillOptional = !!strictResolveValueFromContext(after, GRAPH_API_PROPERTY_NULLABLE);\n      return !argumentWillOptional ? breaking : unclassified;\n    }\n    return nonBreaking;\n  },\n  ({ before }) => {\n    const isRuntimeDirective = isRuntimeDirectiveLocations(strictResolveValueFromContext(before, PARENT_JUMP, PARENT_JUMP, GRAPH_API_PROPERTY_LOCATIONS));\n    return isRuntimeDirective ? breaking : nonBreaking;\n  },\n  unclassified\n];\nconst directiveLocationClassifier = [\n  ({ before, after }) => {\n    const wasRuntime = isRuntimeDirectiveLocations(strictResolveValueFromContext(before, PARENT_JUMP));\n    const willRuntime = isRuntimeDirectiveLocations(strictResolveValueFromContext(after, PARENT_JUMP));\n    return wasRuntime !== willRuntime ? unclassified : nonBreaking;\n  },\n  ({ before, after }) => {\n    const wasRuntime = isRuntimeDirectiveLocations(strictResolveValueFromContext(before, PARENT_JUMP));\n    const willRuntime = isRuntimeDirectiveLocations(strictResolveValueFromContext(after, PARENT_JUMP));\n    return !wasRuntime && !willRuntime ? nonBreaking : breaking;\n  },\n  unclassified\n];\nfunction simpleRule(classify, descriptionTemplate) {\n  return {\n    $: classify,\n    description: diffDescription(descriptionTemplate)\n  };\n}\nconst directivesUsagesRules = {\n  \"/directives\": {\n    \"/*\": {\n      \"/definition\": () => directiveDefinitionRules,\n      //shold make all unclasified\n      \"/meta\": {\n        \"/*\": { $: directiveMetaClassifier }\n      },\n      $: directiveUsageClassifier\n    },\n    newCompareScope: COMPARE_SCOPE_DIRECTIVE_USAGES\n  }\n};\nconst baseRules = {\n  \"/description\": simpleRule(allAnnotation, resolveSchemaDescriptionTemplates(\"description\")),\n  ...directivesUsagesRules\n};\nconst selfNamedBaseRules = {\n  ...baseRules,\n  \"/title\": simpleRule(allUnclassified, resolveSchemaDescriptionTemplates(\"title\"))\n};\nconst directiveDefinitionRules = {\n  ...selfNamedBaseRules,\n  \"/args\": {\n    \"/*\": () => ({\n      ...typeUsageRules,\n      $: directiveArgumentsClassifier\n    })\n    //only scalar, input, enum, and array with it ,\n  },\n  \"/repeatable\": simpleRule(allUnclassified, resolveSchemaDescriptionTemplates(\"repeatable\")),\n  \"/locations\": {\n    \"/*\": () => ({\n      $: directiveLocationClassifier,\n      ignoreKeyDifference: true\n    }),\n    mapping: deepEqualsUniqueItemsArrayMappingResolver\n  }\n};\nconst typeDefinitionRules = {\n  ...selfNamedBaseRules,\n  \"/type\": {\n    // '/kind': // checked inside complexTypeCompareResolver\n    compare: complexTypeCompareResolver,\n    $: allBreaking,\n    //todo support Float->Int changes and compatible interfaces\n    //enum\n    \"/values\": {\n      \"/*\": {\n        ...baseRules,\n        $: [\n          ({ scope }) => riskyIf(scope === COMPARE_SCOPE_OUTPUT),\n          ({ scope }) => breakingIf(scope === COMPARE_SCOPE_ARGS),\n          unclassified\n        ]\n      }\n    },\n    //input\n    \"/properties\": {\n      \"/*\": () => ({\n        ...typeUsageRules,\n        $: [\n          ({ after }) => {\n            var _a;\n            return breakingIf(isObject$1(after.value) && GRAPH_API_PROPERTY_NULLABLE in after.value && !((_a = after.value) == null ? void 0 : _a[GRAPH_API_PROPERTY_NULLABLE]));\n          },\n          breaking,\n          unclassified\n        ]\n      })\n      //only scalar, input, enum, and array with it\n    },\n    //interface object\n    \"/methods\": {\n      \"/*\": () => ({\n        ...methodRules,\n        $: [nonBreaking, breaking, unclassified]\n      })\n    },\n    \"/interfaces\": {\n      \"/*\": () => typeDefinitionRules,\n      // crop to empty array for this parameter cause there are no design for comparing interfaces\n      adapter: [removeNotCorrectlySupportedInterfacesAdapter]\n    },\n    //union\n    \"/oneOf\": {\n      \"/*\": () => ({\n        ...typeDefinitionRules,\n        $: [breaking, breaking, unclassified],\n        ignoreKeyDifference: true\n      }),\n      mapping: titleBaseUniqueItemsArrayMappingResolver\n    },\n    //array\n    \"/items\": () => typeUsageRules\n  },\n  adapter: [graphApiSchemaAdapter]\n};\nconst typeUsageRules = {\n  ...baseRules,\n  \"/default\": {\n    $: defaultClassifier,\n    \"/**\": {\n      $: allUnclassified\n      //todo need samples in compatibility suites\n    }\n  },\n  \"/nullable\": {\n    $: nullableClassifier\n  },\n  \"/typeDef\": typeDefinitionRules\n};\nconst methodRules = {\n  ...baseRules,\n  \"/args\": {\n    \"/*\": {\n      ...typeUsageRules,\n      $: [\n        ({ after }) => {\n          var _a;\n          return breakingIf(isObject$1(after.value) && GRAPH_API_PROPERTY_NULLABLE in after.value && !((_a = after.value) == null ? void 0 : _a[GRAPH_API_PROPERTY_NULLABLE]));\n        },\n        breaking,\n        breaking\n      ]\n    },\n    //only scalar, input, enum, and array with it\n    newCompareScope: COMPARE_SCOPE_ARGS\n  },\n  \"/output\": {\n    ...typeUsageRules,\n    newCompareScope: COMPARE_SCOPE_OUTPUT\n  }\n};\nconst graphApiRules = () => {\n  return {\n    \"/graphapi\": { $: allAnnotation },\n    \"/queries\": {\n      \"/*\": {\n        ...methodRules,\n        $: addNonBreaking\n      }\n    },\n    \"/mutations\": {\n      \"/*\": {\n        ...methodRules,\n        $: addNonBreaking\n      }\n    },\n    \"/subscriptions\": {\n      \"/*\": {\n        ...methodRules,\n        $: addNonBreaking\n      }\n    },\n    \"/components\": {\n      \"/scalars\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      \"/objects\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      \"/interfaces\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      \"/inputObjects\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      \"/directives\": {\n        \"/*\": {\n          ...directiveDefinitionRules,\n          $: directiveDefinitionClassifier\n        }\n      },\n      \"/unions\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      \"/enums\": {\n        \"/*\": {\n          ...typeDefinitionRules,\n          $: addNonBreaking\n        }\n      },\n      newCompareScope: COMPARE_SCOPE_COMPONENTS$1\n    }\n  };\n};\nconst compareGraphApi = (before, after, options) => {\n  return compare(before, after, {\n    ...options,\n    rules: graphApiRules()\n  });\n};\nconst asyncApi2Rules = (_) => {\n  const subSchemaRules = transformCompareRules(jsonSchemaRules({\n    additionalRules: {},\n    version: SPEC_TYPE_JSON_SCHEMA_07\n  }), reverseClassifyRuleTransformer);\n  const pubSchemaRules = jsonSchemaRules({\n    additionalRules: {},\n    version: SPEC_TYPE_JSON_SCHEMA_07\n  });\n  const correlationIdRules = {\n    $: addNonBreaking,\n    \"/location\": { $: addNonBreaking },\n    \"/description\": { $: allAnnotation }\n  };\n  const bindingsRule = {\n    $: allUnclassified,\n    \"/*\": {\n      $: allUnclassified,\n      \"/*\": { $: allUnclassified },\n      \"/query\": () => subSchemaRules,\n      \"/headers\": () => pubSchemaRules\n    }\n  };\n  const commonRules = {\n    \"/summary\": { $: allAnnotation },\n    \"/tags\": { $: allAnnotation },\n    \"/externalDocs\": { $: allAnnotation },\n    \"/bindings\": bindingsRule\n  };\n  const pubsubTraitsRules = {\n    $: addNonBreaking,\n    \"/*\": { $: addNonBreaking },\n    \"/operationId\": { $: allAnnotation },\n    \"/description\": { $: allAnnotation },\n    ...commonRules\n  };\n  const messageTraitsRules = {\n    $: addNonBreaking,\n    \"/*\": { $: addNonBreaking },\n    \"/headers\": { $: allUnclassified },\n    \"/correlationId\": correlationIdRules,\n    \"/schemaFormat\": { $: allBreaking },\n    \"/contentType\": { $: addNonBreaking },\n    \"/name\": { $: allNonBreaking },\n    \"/title\": { $: allNonBreaking },\n    \"/examples\": { $: allAnnotation },\n    ...commonRules\n  };\n  const messageRules = (sub = false) => ({\n    $: allBreaking,\n    \"/headers\": { $: allUnclassified },\n    \"/correlationId\": correlationIdRules,\n    \"/schemaFormat\": { $: allBreaking },\n    \"/contentType\": { $: addNonBreaking },\n    \"/name\": { $: allNonBreaking },\n    \"/title\": { $: allAnnotation },\n    \"/description\": { $: allAnnotation },\n    \"/examples\": { $: allAnnotation },\n    \"/traits\": messageTraitsRules,\n    \"/payload\": () => ({\n      ...sub ? subSchemaRules : pubSchemaRules,\n      $: allBreaking\n    }),\n    ...commonRules\n  });\n  const pubsubRules = (sub = false) => ({\n    $: addNonBreaking,\n    \"/operationId\": { $: allAnnotation },\n    \"/description\": { $: allAnnotation },\n    \"/traits\": pubsubTraitsRules,\n    \"/message\": messageRules(sub),\n    ...commonRules\n  });\n  const infoRules = {\n    $: allAnnotation,\n    \"/version\": { $: allAnnotation },\n    \"/termsOfService\": { $: allAnnotation },\n    \"/license\": {\n      $: allAnnotation,\n      \"/name\": { $: allAnnotation },\n      \"/url\": { $: allAnnotation }\n    },\n    \"/title\": { $: allAnnotation },\n    \"/description\": { $: allAnnotation },\n    \"/contact\": {\n      $: allAnnotation,\n      \"/name\": { $: allAnnotation },\n      \"/url\": { $: allAnnotation },\n      \"/email\": { $: allAnnotation }\n    }\n  };\n  const serversRules = {\n    $: allAnnotation,\n    \"/*\": {\n      $: allAnnotation,\n      \"/url\": { $: allAnnotation },\n      \"/description\": { $: allAnnotation },\n      \"/protocol\": { $: allAnnotation },\n      \"/protocolVersion\": { $: allAnnotation },\n      \"/variables\": {\n        $: allAnnotation,\n        \"/*\": {\n          $: allAnnotation,\n          \"/enum\": {\n            $: allAnnotation,\n            \"/*\": { $: allAnnotation }\n          },\n          \"/default\": { $: allAnnotation },\n          \"/description\": { $: allAnnotation },\n          \"/examples\": { $: allAnnotation }\n        }\n      },\n      \"/security\": {\n        $: allAnnotation,\n        \"/*\": { $: allAnnotation }\n      },\n      \"/bindings\": bindingsRule\n    }\n  };\n  const channelRules = {\n    $: addNonBreaking,\n    \"/description\": { $: allAnnotation },\n    \"/bindings\": bindingsRule,\n    \"/subscribe\": pubsubRules(true),\n    \"/publish\": pubsubRules(false),\n    \"/parameters\": {\n      $: allBreaking,\n      \"/*\": {\n        $: addNonBreaking,\n        \"/description\": { $: allAnnotation },\n        \"/schema\": () => ({\n          ...pubSchemaRules,\n          $: allBreaking\n        }),\n        \"/location\": { $: allBreaking }\n      }\n    }\n  };\n  return {\n    \"/asyncapi\": { $: allAnnotation },\n    \"/id\": { $: allAnnotation },\n    \"/defaultContentType\": { $: allBreaking },\n    \"/info\": infoRules,\n    \"/servers\": serversRules,\n    \"/channels\": {\n      $: addNonBreaking,\n      \"/*\": channelRules\n    },\n    \"/components\": {\n      \"/*\": { $: allAnnotation }\n    },\n    \"/tags\": { $: allAnnotation },\n    \"/externalDocs\": { $: allAnnotation }\n  };\n};\nconst compareAsyncApi = (before, after, options) => {\n  return compare(before, after, {\n    ...options,\n    rules: asyncApi2Rules(options.mode)\n  });\n};\nconst emptySecurity = (value) => {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  return !!value && (value.length === 0 || value.length === 1 && Object.keys(value[0]).length === 0);\n};\nconst includeSecurity = (value = [], items = []) => {\n  if (!Array.isArray(value) || !Array.isArray(items) || items.length === 0) {\n    return false;\n  }\n  const valueSet = new Set(value.map((item) => Object.keys(item)[0]));\n  for (const item of items) {\n    if (!valueSet.has(Object.keys(item)[0])) {\n      return false;\n    }\n  }\n  return true;\n};\nconst extractPathContext = (ctx, jumpsToPathLevel) => {\n  let context = ctx;\n  for (let i = 0; i < jumpsToPathLevel; i++) {\n    context = context == null ? void 0 : context.parentContext;\n  }\n  return context;\n};\nconst extractPaths = (ctx, jumpsToPathLevel) => {\n  const pathContext = extractPathContext(ctx, jumpsToPathLevel);\n  if (!pathContext) {\n    return;\n  }\n  const { before: { key: pathBefore }, after: { key: pathAfter } } = pathContext;\n  return [pathBefore, pathAfter];\n};\nconst mapPathParams = (ctx, jumpsToPathLevel) => {\n  const [pathBefore, pathAfter] = extractPaths(ctx, jumpsToPathLevel) ?? [];\n  if (!isString(pathBefore) || !isString(pathAfter)) {\n    return {};\n  }\n  const beforeParams = [...pathBefore.matchAll(new RegExp(\"{(.*?)}\", \"g\"))].map((arr) => arr.pop());\n  const afterParams = [...pathAfter.matchAll(new RegExp(\"{(.*?)}\", \"g\"))].map((arr) => arr.pop());\n  const result = {};\n  for (let i = 0; i < beforeParams.length && i < afterParams.length; i++) {\n    result[beforeParams[i]] = afterParams[i];\n  }\n  return result;\n};\nconst isResponseSchema = (path) => {\n  return path[3] === \"responses\" && path[7] === \"schema\";\n};\nconst singleOperationPathMappingResolver = (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const beforeKeys = objectKeys(before);\n  const afterKeys = objectKeys(after);\n  const keysMaxLength = Math.max(beforeKeys.length, afterKeys.length);\n  for (let i = 0; i < keysMaxLength; i++) {\n    if (!beforeKeys[i]) {\n      result.added.push(afterKeys[i]);\n    } else if (!afterKeys[i]) {\n      result.removed.push(beforeKeys[i]);\n    } else {\n      result.mapped[beforeKeys[i]] = afterKeys[i];\n    }\n  }\n  return result;\n};\nconst pathMappingResolver = (before, after, ctx) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const unifyBeforePath = createPathUnifier(ctx.before.root.servers);\n  const unifyAfterPath = createPathUnifier(ctx.after.root.servers);\n  const unifiedBeforeKeyToKey = Object.fromEntries(objectKeys(before).map((key) => {\n    var _a;\n    return [unifyBeforePath(key, (_a = before[key]) == null ? void 0 : _a.servers), key];\n  }));\n  const unifiedAfterKeyToKey = Object.fromEntries(objectKeys(after).map((key) => {\n    var _a;\n    return [unifyAfterPath(key, (_a = after[key]) == null ? void 0 : _a.servers), key];\n  }));\n  const unifiedBeforeKeys = Object.keys(unifiedBeforeKeyToKey);\n  const unifiedAfterKeys = Object.keys(unifiedAfterKeyToKey);\n  result.added = difference(unifiedAfterKeys, unifiedBeforeKeys).map((key) => unifiedAfterKeyToKey[key]);\n  result.removed = difference(unifiedBeforeKeys, unifiedAfterKeys).map((key) => unifiedBeforeKeyToKey[key]);\n  result.mapped = Object.fromEntries(\n    intersection(unifiedBeforeKeys, unifiedAfterKeys).map((key) => [unifiedBeforeKeyToKey[key], unifiedAfterKeyToKey[key]])\n  );\n  return result;\n};\nconst methodMappingResolver = (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const beforeKeys = objectKeys(before);\n  const afterKeys = objectKeys(after);\n  result.added = difference(afterKeys, beforeKeys);\n  result.removed = difference(beforeKeys, afterKeys);\n  const mapped = intersection(beforeKeys, afterKeys);\n  mapped.forEach((key) => result.mapped[key] = key);\n  return result;\n};\nconst paramMappingResolver = (pathLevel) => {\n  return (before, after, ctx) => {\n    const result = { added: [], removed: [], mapped: {} };\n    const pathParamMapping = mapPathParams(ctx, pathLevel);\n    const afterKeys = onlyExistedArrayIndexes(after);\n    const beforeKeys = onlyExistedArrayIndexes(before);\n    const mappedIndex = new Set(afterKeys);\n    beforeKeys.forEach((i) => {\n      const beforeIn = getStringValue(before[i], \"in\");\n      const beforeName = getStringValue(before[i], \"name\") ?? \"\";\n      const _afterIndex = after.findIndex((a) => {\n        const afterIn = getStringValue(a, \"in\");\n        const afterName = getStringValue(a, \"name\") ?? \"\";\n        return beforeIn === afterIn && (beforeName === afterName || beforeIn === \"path\" && pathParamMapping[beforeName] === afterName);\n      });\n      if (_afterIndex < 0) {\n        result.removed.push(i);\n      } else {\n        result.mapped[i] = _afterIndex;\n        mappedIndex.delete(_afterIndex);\n      }\n    });\n    mappedIndex.forEach((i) => result.added.push(i));\n    return result;\n  };\n};\nconst contentMediaTypeMappingResolver = (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const beforeKeys = objectKeys(before);\n  const afterKeys = objectKeys(after);\n  const unmappedAfterIndices = new Set(afterKeys.keys());\n  const unmappedBeforeIndices = new Set(beforeKeys.keys());\n  function mapExactMatches(getComparisonKey) {\n    for (const beforeIndex of unmappedBeforeIndices) {\n      const beforeKey = getComparisonKey(beforeKeys[beforeIndex]);\n      let matchingAfterIndex;\n      for (const afterIndex of unmappedAfterIndices) {\n        const afterKey = getComparisonKey(afterKeys[afterIndex]);\n        if (afterKey === beforeKey) {\n          matchingAfterIndex = afterIndex;\n          break;\n        }\n      }\n      if (matchingAfterIndex !== void 0) {\n        result.mapped[beforeKeys[beforeIndex]] = afterKeys[matchingAfterIndex];\n        unmappedAfterIndices.delete(matchingAfterIndex);\n        unmappedBeforeIndices.delete(beforeIndex);\n      }\n    }\n  }\n  mapExactMatches((key) => key);\n  mapExactMatches(getMediaTypeBase);\n  if (unmappedBeforeIndices.size === 1 && unmappedAfterIndices.size === 1) {\n    const beforeIndex = Array.from(unmappedBeforeIndices)[0];\n    const afterIndex = Array.from(unmappedAfterIndices)[0];\n    const beforeKey = beforeKeys[beforeIndex];\n    const afterKey = afterKeys[afterIndex];\n    const beforeBaseType = getMediaTypeBase(beforeKey);\n    const afterBaseType = getMediaTypeBase(afterKey);\n    if (isWildcardCompatible(beforeBaseType, afterBaseType)) {\n      result.mapped[beforeKeys[beforeIndex]] = afterKeys[afterIndex];\n      unmappedAfterIndices.delete(afterIndex);\n      unmappedBeforeIndices.delete(beforeIndex);\n    }\n  }\n  unmappedBeforeIndices.forEach((index) => result.removed.push(beforeKeys[index]));\n  unmappedAfterIndices.forEach((index) => result.added.push(afterKeys[index]));\n  return result;\n};\nfunction getMediaTypeBase(mediaType) {\n  return mediaType.split(\";\")[0] ?? \"\";\n}\nfunction isWildcardCompatible(beforeType, afterType) {\n  const [beforeMainType, beforeSubType] = beforeType.split(\"/\");\n  const [afterMainType, afterSubType] = afterType.split(\"/\");\n  if (beforeMainType !== afterMainType && beforeMainType !== \"*\" && afterMainType !== \"*\") {\n    return false;\n  }\n  if (beforeSubType !== afterSubType && beforeSubType !== \"*\" && afterSubType !== \"*\") {\n    return false;\n  }\n  return true;\n}\nfunction createPathUnifier(rootServers) {\n  return (path, pathServers) => {\n    const serverPrefix = extractOperationBasePath(pathServers || rootServers);\n    return removeExcessiveSlashes(`${serverPrefix}${hidePathParamNames(path)}`);\n  };\n}\nfunction hidePathParamNames(path) {\n  return path.replace(PATH_PARAMETER_REGEXP, PATH_PARAM_UNIFIED_PLACEHOLDER);\n}\nconst PATH_PARAMETER_REGEXP = /\\{.*?\\}/g;\nconst PATH_PARAM_UNIFIED_PLACEHOLDER = \"*\";\nconst paramClassifyRule = [\n  ({ after }) => {\n    if (isIgnoredHeaderParam(after.value)) {\n      return unclassified;\n    }\n    return getKeyValue(after.value, \"required\") && !isExist(getKeyValue(after.value, \"schema\", \"default\")) ? breaking : nonBreaking;\n  },\n  ({ before }) => {\n    return isIgnoredHeaderParam(before.value) ? unclassified : breaking;\n  },\n  unclassified\n];\nconst NON_BREAKING_HEADERS = [\"Accept\", \"Content-Type\", \"Authorization\", \"authorization\"];\nconst isIgnoredHeaderParam = (param) => {\n  return param.in === \"header\" && NON_BREAKING_HEADERS.includes(param.name);\n};\nconst apihubParametersRemovalClassifyRule = (ctx) => {\n  const { before: { value } } = ctx;\n  if (!Array.isArray(value)) {\n    return breaking;\n  }\n  return value.every(isIgnoredHeaderParam) ? nonBreaking : breaking;\n};\nconst parameterExplodeClassifyRule = [\n  ({ after }) => after.value && getKeyValue(after.parent, \"style\") === \"form\" || !after.value && getKeyValue(after.parent, \"style\") !== \"form\" ? annotation : breaking,\n  ({ before }) => before.value && getKeyValue(before.parent, \"style\") === \"form\" || !before.value && getKeyValue(before.parent, \"style\") !== \"form\" ? annotation : breaking,\n  breaking\n];\nconst parameterAllowReservedClassifyRule = [\n  ({ after }) => [\"path\", \"cookie\", \"header\"].includes(getKeyValue(after.parent, \"in\")) ? unclassified : nonBreaking,\n  ({ after }) => [\"path\", \"cookie\", \"header\"].includes(getKeyValue(after.parent, \"in\")) ? unclassified : breaking,\n  ({ after }) => {\n    if ([\"path\", \"cookie\", \"header\"].includes(getKeyValue(after.parent, \"in\"))) {\n      return unclassified;\n    }\n    return after.value ? nonBreaking : breaking;\n  }\n];\nconst parameterNameClassifyRule = [\n  nonBreaking,\n  breaking,\n  ({ before }) => getKeyValue(before.parent, \"in\") === \"path\" ? annotation : breaking\n];\nconst parameterRequiredClassifyRule = [\n  breaking,\n  nonBreaking,\n  (ctx) => getKeyValue(ctx.after.parent, \"schema\", \"default\") ? nonBreaking : breakingIfAfterTrue(ctx)\n];\nconst apihubAllowEmptyValueParameterClassifyRule = transformClassifyRule(\n  reverseClassifyRule(booleanClassifier),\n  (type, { after }, action) => getKeyValue(after.parent, \"in\") === \"query\" ? type : unclassified\n);\nconst globalSecurityClassifyRule = [\n  ({ after }) => !emptySecurity(after.value) ? breaking : nonBreaking,\n  nonBreaking,\n  ({\n    after,\n    before\n  }) => includeSecurity(after.value, before.value) || emptySecurity(after.value) ? nonBreaking : breaking\n];\nconst globalSecurityItemClassifyRule = [\n  ({ before }) => isNotEmptyArray(before.parent) ? nonBreaking : breaking,\n  ({ after }) => isNotEmptyArray(after.parent) ? nonBreaking : breaking,\n  ({\n    after,\n    before\n  }) => includeSecurity(after.parent, before.parent) || emptySecurity(after.value) ? nonBreaking : breaking\n];\nconst operationSecurityClassifyRule = [\n  ({\n    before,\n    after\n  }) => emptySecurity(after.value) || includeSecurity(after.value, getKeyValue(before.root, \"security\")) ? nonBreaking : breaking,\n  ({ before, after }) => includeSecurity(getKeyValue(after.root, \"security\"), before.value) ? nonBreaking : breaking,\n  ({\n    before,\n    after\n  }) => includeSecurity(after.value, before.value) || emptySecurity(after.value) ? nonBreaking : breaking\n];\nconst operationSecurityItemClassifyRule = [\n  ({ before }) => isNotEmptyArray(before.parent) ? nonBreaking : breaking,\n  ({ after }) => isNotEmptyArray(after.parent) ? breaking : nonBreaking,\n  ({\n    before,\n    after\n  }) => includeSecurity(after.parent, before.parent) || emptySecurity(after.value) ? nonBreaking : breaking\n];\nconst pathChangeClassifyRule = [\n  nonBreaking,\n  breaking,\n  ({ before, after, parentContext }) => {\n    var _a, _b, _c, _d;\n    const beforePath = before.key;\n    const afterPath = after.key;\n    const beforeRootServers = (_a = parentContext == null ? void 0 : parentContext.before.root) == null ? void 0 : _a.servers;\n    const beforePathItemServers = (_b = before.value) == null ? void 0 : _b.servers;\n    const afterRootServers = (_c = parentContext == null ? void 0 : parentContext.after.root) == null ? void 0 : _c.servers;\n    const afterPathItemServers = (_d = after.value) == null ? void 0 : _d.servers;\n    const unifiedBeforePath = createPathUnifier(beforeRootServers)(beforePath, beforePathItemServers);\n    const unifiedAfterPath = createPathUnifier(afterRootServers)(afterPath, afterPathItemServers);\n    return unifiedBeforePath === unifiedAfterPath ? annotation : breaking;\n  }\n];\nconst calculateChangedProperty = (matchResult, ignoredLastProperty = false) => {\n  const path = calculateMatchingPathEnd(matchResult, ignoredLastProperty);\n  if (isEmptyArray(path)) {\n    return void 0;\n  }\n  return path.join(\".\");\n};\nconst calculateMatchingPathEnd = (matchResult, ignoredLastProperty = false) => {\n  let matchingDepth = calculateMatchingDepth(matchResult);\n  matchingDepth = ignoredLastProperty ? matchingDepth + 1 : matchingDepth;\n  return matchResult.path.slice(matchingDepth);\n};\nconst calculateComponentsPath = (matchResult) => {\n  return matchResult.path.slice(0, 3).join(\".\");\n};\nconst calculateRequestPlace = (matchResult) => {\n  let place;\n  const mediaType = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_MEDIA_TYPE]);\n  if (startFromOpenApiComponents(matchResult.path)) {\n    const requestPath = calculateComponentsPath(matchResult);\n    place = `in '${requestPath}' (${mediaType})`;\n  } else {\n    place = `in request body (${mediaType})`;\n  }\n  return place;\n};\nconst calculateResponsePlace = (matchResult) => {\n  let place;\n  const mediaType = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_MEDIA_TYPE]);\n  if (startFromOpenApiComponents(matchResult.path)) {\n    const responsePath = calculateComponentsPath(matchResult);\n    place = `in '${responsePath}' (${mediaType})`;\n  } else {\n    const responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    place = `in response '${responseName}' (${mediaType})`;\n  }\n  return place;\n};\nconst calculateParameterPlace = (matchResult, diff, ctx, depthInParameter = 0) => {\n  let parameterName;\n  let parameterIn;\n  let parameterPath;\n  let place;\n  if (startFromOpenApiComponents(matchResult.path)) {\n    parameterPath = calculateComponentsPath(matchResult);\n    place = `in '${parameterPath}'`;\n  } else {\n    const matchingDepth = calculateMatchingDepth(matchResult);\n    const parameterNode = resolveValueFromCompareContext(diff, ctx, ...calculateParentJumpDeep(matchResult.path.length - matchingDepth + 1 - depthInParameter));\n    if (!parameterNode) {\n      return void 0;\n    }\n    parameterName = checkPrimitiveType(parameterNode[\"name\"]);\n    parameterIn = checkPrimitiveType(parameterNode[\"in\"]);\n    place = `in ${parameterIn} parameter '${parameterName}'`;\n  }\n  return place;\n};\nconst calculateHeaderPlace = (matchResult) => {\n  let place;\n  let headerName;\n  let headerPath;\n  if (startFromOpenApiComponents(matchResult.path)) {\n    headerPath = calculateComponentsPath(matchResult);\n    place = `in '${headerPath}'`;\n  } else {\n    headerName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_HEADER_NAME]);\n    place = `in header '${headerName}'`;\n  }\n  return place;\n};\nconst calculateEncodingPlaceInResponse = (matchResult) => {\n  let responsePath;\n  const mediaType = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_MEDIA_TYPE]);\n  if (startFromOpenApiComponents(matchResult.path)) {\n    const componentsResponsePath = calculateComponentsPath(matchResult);\n    responsePath = `'${componentsResponsePath}' (${mediaType})`;\n  } else {\n    const responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    responsePath = `response '${responseName}' (${mediaType})`;\n  }\n  const headerName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_HEADER_NAME]);\n  const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n  return `in header ${headerName} of encoding '${encodingName}' of ${responsePath}`;\n};\nconst calculateEncodingPlaceInRequest = (matchResult) => {\n  let requestPath;\n  const mediaType = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_MEDIA_TYPE]);\n  if (startFromOpenApiComponents(matchResult.path)) {\n    const componentsRequestPath = calculateComponentsPath(matchResult);\n    requestPath = `'${componentsRequestPath}' (${mediaType})`;\n  } else {\n    requestPath = `request body (${mediaType})`;\n  }\n  const headerName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_HEADER_NAME]);\n  const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n  return `in header ${headerName} of encoding '${encodingName}' of ${requestPath}`;\n};\nconst encodingParamsCalculator = (diff, _) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_ENCODING_IN_REQUEST);\n  if (matchResult) {\n    const place = calculateRequestPlace(matchResult);\n    const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n    return {\n      ...result,\n      encodingName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_ENCODING_IN_RESPONSE);\n  if (matchResult) {\n    const place = calculateResponsePlace(matchResult);\n    const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n    return {\n      ...result,\n      encodingName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_REQUEST);\n  if (matchResult) {\n    const encodingParams = calculateEncodingParamsInRequest(matchResult);\n    return {\n      ...result,\n      ...encodingParams\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_RESPONSE);\n  if (matchResult) {\n    const encodingParams = calculateEncodingParamsInResponse(matchResult);\n    return {\n      ...result,\n      ...encodingParams\n    };\n  }\n  return result;\n};\nconst calculateEncodingParamsInResponse = (matchResult) => {\n  const place = calculateResponsePlace(matchResult);\n  const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n  const propertyName = calculateChangedProperty(matchResult, true);\n  return { place, encodingName, propertyName };\n};\nconst calculateEncodingParamsInRequest = (matchResult) => {\n  const place = calculateRequestPlace(matchResult);\n  const encodingName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_ENCODING_NAME]);\n  const propertyName = calculateChangedProperty(matchResult, true);\n  return { place, encodingName, propertyName };\n};\nconst PREDICATES_PATHS_FOR_CHANGED_ENCODING_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_ENCODING_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_UNCLOSED_END])\n];\nconst schemaParamsCalculator = (diff, ctx) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_COMPONENTS);\n  if (matchResult) {\n    const scope = diff.scope;\n    const componentsSchemaPath = calculateComponentsPath(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult, componentsSchemaPath);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      scope\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_PARAMETER);\n  if (matchResult) {\n    const place = calculateParameterPlace(matchResult, diff, ctx, 1);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_REQUEST);\n  if (matchResult) {\n    const place = calculateRequestPlace(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_RESPONSE);\n  if (matchResult) {\n    const place = calculateResponsePlace(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_HEADER);\n  if (matchResult) {\n    const place = calculateHeaderPlace(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_HEADER_IN_RESPONSE);\n  if (matchResult) {\n    const place = calculateHeaderPlace(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_RESPONSE);\n  if (matchResult) {\n    const place = calculateEncodingPlaceInResponse(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_REQUEST);\n  if (matchResult) {\n    const place = calculateEncodingPlaceInRequest(matchResult);\n    const commonSchemaParams = calculateCommonSchemaParams(matchResult);\n    return {\n      ...result,\n      ...commonSchemaParams,\n      place\n    };\n  }\n  return result;\n};\nconst calculateCommonSchemaParams = (schemaMatchResult, componentsSchemaPath) => {\n  let schemaPath;\n  const pathEnd = calculateMatchingPathEnd(schemaMatchResult);\n  if (pathEnd.length < 4) {\n    schemaPath = componentsSchemaPath;\n    return { schemaPath };\n  }\n  if (pathEnd[0] !== OPEN_API_PROPERTY_SCHEMA) {\n    pathEnd.shift();\n  }\n  pathEnd.pop();\n  schemaPath = pathEnd.join(\".\");\n  if (componentsSchemaPath) {\n    schemaPath = schemaPath ? [componentsSchemaPath, schemaPath].join(\".\") : componentsSchemaPath;\n  }\n  return { schemaPath };\n};\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_COMPONENTS = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_SCHEMAS, PREDICATE_ANY_VALUE, PREDICATE_UNCLOSED_END]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_PARAMETER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_HEADER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_SCHEMA_IN_HEADER_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_SCHEMA, PREDICATE_UNCLOSED_END])\n];\nconst calculateOasExtensionDiffDescription = (diff) => {\n  const declarationPaths = getDeclarationPathsForDiff(diff);\n  if (declarationPaths.length === 0) {\n    return \"\";\n  }\n  const splitPaths = declarationPaths.map((path) => splitPathAtExtension(path));\n  const extensionPath = splitPaths[0].extensionPath;\n  const action = DIFF_ACTION_TO_ACTION_MAP[diff.action];\n  const preposition = DIFF_ACTION_TO_PREPOSITION_MAP[diff.action];\n  const placePaths = splitPaths.map((splitPath) => splitPath.remainingPath).filter((path) => path !== void 0);\n  const place = placePaths.length > 0 ? placePaths.join(\", \") : \"root\";\n  return `[${action}] extension '${extensionPath}' ${preposition} ${place}`;\n};\nconst splitPathAtExtension = (path) => {\n  let extensionIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    const pathElement = path[i];\n    if (typeof pathElement === \"string\" && pathElement.startsWith(\"x-\")) {\n      extensionIndex = i;\n      break;\n    }\n  }\n  if (extensionIndex === -1) {\n    return { extensionPath: path.join(\".\"), remainingPath: void 0 };\n  }\n  const extensionParts = path.slice(extensionIndex);\n  const extensionPath = extensionParts.join(\".\");\n  const remainingParts = path.slice(0, extensionIndex);\n  const remainingPath = remainingParts.length > 0 ? remainingParts.join(\".\") : void 0;\n  return { extensionPath, remainingPath };\n};\nconst openApiSpecificationExtensionRulesFunction = (classification = allUnclassified) => {\n  const oasExtensionPrefixRules = {\n    \"x-\": {\n      $: classification,\n      description: calculateOasExtensionDiffDescription,\n      \"/*\": {\n        $: classification,\n        description: calculateOasExtensionDiffDescription\n      },\n      \"/**\": {\n        $: classification,\n        description: calculateOasExtensionDiffDescription\n      }\n    }\n  };\n  return { \"/^\": oasExtensionPrefixRules };\n};\nconst NULL_TYPE_COMBINERS = [JSON_SCHEMA_PROPERTY_ANY_OF, JSON_SCHEMA_PROPERTY_ONE_OF];\nconst SPEC_TYPE_TO_VERSION = {\n  [SPEC_TYPE_OPEN_API_30]: \"3.0.0\",\n  [SPEC_TYPE_OPEN_API_31]: \"3.1.0\"\n};\nconst openApiJsonSchemaAnyFactory = (version) => (schema, schemaOrigins, opt) => {\n  const normalizedSpec = normalize({\n    openapi: SPEC_TYPE_TO_VERSION[version],\n    components: {\n      schemas: {\n        empty: schema,\n        [opt.originsFlag]: {\n          empty: schemaOrigins\n        }\n      },\n      [opt.originsFlag]: {\n        schemas: schemaOrigins\n      }\n    },\n    [opt.originsFlag]: {\n      components: schemaOrigins\n    }\n  }, {\n    ...opt,\n    // schema is already normalized, resolveRef is disabled and originsAlreadyDefined is true in order to prevent origins override\n    resolveRef: false,\n    originsAlreadyDefined: true,\n    validate: false,\n    allowNotValidSyntheticChanges: false\n  });\n  return normalizedSpec.components.schemas.empty;\n};\nconst hasNullType = (schema) => {\n  if (!isObject(schema)) {\n    return false;\n  }\n  const type = schema[JSON_SCHEMA_PROPERTY_TYPE];\n  if (type === JSON_SCHEMA_NODE_TYPE_NULL) {\n    return true;\n  }\n  if (isArray(type) && type.includes(JSON_SCHEMA_NODE_TYPE_NULL)) {\n    return true;\n  }\n  return NULL_TYPE_COMBINERS.some((combiner) => {\n    const variants = schema[combiner];\n    return isArray(variants) && variants.some(hasNullType);\n  });\n};\nconst buildNullTypeWithOrigins = (valueWithoutNullable, context, factory) => {\n  const { options, valueOrigins } = context;\n  const { originsFlag, syntheticTitleFlag } = options;\n  const nullTypeObject = factory(\n    { [JSON_SCHEMA_PROPERTY_TYPE]: JSON_SCHEMA_NODE_TYPE_NULL },\n    valueOrigins,\n    options\n  );\n  const inputOrigins = valueWithoutNullable[originsFlag];\n  const nullTypeOrigins = isObject(nullTypeObject[originsFlag]) ? nullTypeObject[originsFlag] : {};\n  const nullable = inputOrigins && inputOrigins.nullable;\n  if (nullable) {\n    const getOriginParent = (item) => ({\n      value: JSON_SCHEMA_PROPERTY_TYPE,\n      parent: item == null ? void 0 : item.parent\n    });\n    nullTypeOrigins[JSON_SCHEMA_PROPERTY_TYPE] = isArray(nullable) ? nullable.map(getOriginParent) : getOriginParent(nullable);\n  }\n  const title = valueWithoutNullable[JSON_SCHEMA_PROPERTY_TITLE];\n  if (title) {\n    nullTypeObject[JSON_SCHEMA_PROPERTY_TITLE] = title;\n    const titleOrigins = inputOrigins && inputOrigins[JSON_SCHEMA_PROPERTY_TITLE];\n    if (titleOrigins) {\n      nullTypeOrigins[JSON_SCHEMA_PROPERTY_TITLE] = titleOrigins;\n    }\n  }\n  if (syntheticTitleFlag && valueWithoutNullable[syntheticTitleFlag]) {\n    nullTypeObject[syntheticTitleFlag] = true;\n  }\n  return nullTypeObject;\n};\nconst jsonSchemaOas30to31Adapter = (factory) => (value, reference, valueContext) => {\n  if (!isObject(value) || !isObject(reference)) {\n    return value;\n  }\n  if (value[JSON_SCHEMA_PROPERTY_NULLABLE] !== true) {\n    return value;\n  }\n  if (!hasNullType(reference)) {\n    return value;\n  }\n  const { originsFlag } = valueContext.options;\n  return valueContext.transformer(value, \"nullable-to-anyof\", (current) => {\n    if (!isObject(current)) {\n      return current;\n    }\n    const {\n      [JSON_SCHEMA_PROPERTY_NULLABLE]: _nullable,\n      ...valueWithoutNullable\n    } = current;\n    const nullTypeObject = buildNullTypeWithOrigins(valueWithoutNullable, valueContext, factory);\n    cleanOrigins(valueWithoutNullable, JSON_SCHEMA_PROPERTY_NULLABLE, originsFlag);\n    const anyOfArray = [valueWithoutNullable, nullTypeObject];\n    const result = { [JSON_SCHEMA_PROPERTY_ANY_OF]: anyOfArray };\n    setOrigins(result, JSON_SCHEMA_PROPERTY_ANY_OF, originsFlag, valueContext.valueOrigins);\n    setOrigins(anyOfArray, 0, originsFlag, valueContext.valueOrigins);\n    setOrigins(anyOfArray, 1, originsFlag, valueContext.valueOrigins);\n    return result;\n  });\n};\nconst openApiSchemaRules = (options) => {\n  const jsonSchemaVersion = options.version === SPEC_TYPE_OPEN_API_30 ? SPEC_TYPE_JSON_SCHEMA_04 : SPEC_TYPE_JSON_SCHEMA_07;\n  const schemaRules = jsonSchemaRules({\n    additionalRules: {\n      adapter: [\n        ...options.version === SPEC_TYPE_OPEN_API_31 ? [jsonSchemaOas30to31Adapter(openApiJsonSchemaAnyFactory(options.version))] : [],\n        jsonSchemaAdapter(openApiJsonSchemaAnyFactory(options.version))\n      ],\n      descriptionParamCalculator: schemaParamsCalculator,\n      description: diffDescription(resolveSchemaDescriptionTemplates()),\n      // openapi extensions\n      \"/nullable\": {\n        $: [\n          nonBreaking,\n          breaking,\n          ({ after }) => breakingIf(!after.value),\n          breakingIfAfterTrue,\n          nonBreaking,\n          ({ after }) => breakingIf(!!after.value)\n        ],\n        description: diffDescription(resolveSchemaDescriptionTemplates(\"nullable status\"))\n      },\n      \"/discriminator\": { $: allUnclassified },\n      \"/example\": { $: allAnnotation, description: diffDescription(resolveSchemaDescriptionTemplates(\"example\")) },\n      \"/externalDocs\": {\n        $: allAnnotation,\n        description: diffDescription(resolveSchemaDescriptionTemplates(\"externalDocs\")),\n        \"/description\": {\n          $: allAnnotation,\n          description: diffDescription(resolveSchemaDescriptionTemplates(\"description of externalDocs\"))\n        },\n        \"/url\": {\n          $: allAnnotation,\n          description: diffDescription(resolveSchemaDescriptionTemplates(\"url of externalDocs\"))\n        },\n        ...openApiSpecificationExtensionRulesFunction(allAnnotation),\n        \"/*\": {\n          $: allAnnotation,\n          description: diffDescription(resolveSchemaDescriptionTemplates(\"externalDocs\"))\n        }\n      },\n      \"/xml\": {\n        ...openApiSpecificationExtensionRulesFunction()\n      },\n      ...openApiSpecificationExtensionRulesFunction()\n    },\n    version: jsonSchemaVersion\n  });\n  return options.response ? transformCompareRules(schemaRules, reverseClassifyRuleTransformer) : schemaRules;\n};\nconst apihubCaseInsensitiveKeyMappingResolver = (before, after) => {\n  const result = { added: [], removed: [], mapped: {} };\n  const afterKeys = [...new Set(Object.keys(after))];\n  for (const _key of Object.keys(before)) {\n    const key = _key.toLocaleLowerCase();\n    const afterKeyIndex = afterKeys.findIndex((value) => value.toLocaleLowerCase() === key);\n    if (afterKeyIndex !== -1) {\n      result.mapped[_key] = afterKeys[afterKeyIndex];\n      afterKeys.splice(afterKeyIndex, 1);\n    } else {\n      result.removed.push(key);\n    }\n  }\n  afterKeys.forEach((key) => result.added.push(key));\n  return result;\n};\nconst COMPARE_SCOPE_REQUEST = \"request\";\nconst COMPARE_SCOPE_RESPONSE = \"response\";\nconst COMPARE_SCOPE_COMPONENTS = \"components\";\nconst parameterParamsCalculator = (diff, ctx) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const calculateCommonParams = (matchResult2, parameterNode) => {\n    let parameterPath;\n    let parameterName;\n    const parameterLocation = checkPrimitiveType(parameterNode[\"in\"]);\n    if (startFromOpenApiComponents(matchResult2.path)) {\n      parameterPath = calculateComponentsPath(matchResult2);\n    } else {\n      parameterName = checkPrimitiveType(parameterNode[\"name\"]);\n    }\n    return { parameterLocation, parameterPath, parameterName };\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_PARAMETER);\n  if (matchResult) {\n    const parameterNode = resolveCurrentNode(diff, ctx);\n    if (!parameterNode) {\n      return FAILED_PARAMS_CALCULATION;\n    }\n    const commonParams = calculateCommonParams(matchResult, parameterNode);\n    return {\n      ...result,\n      ...commonParams\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_PARAMETER);\n  if (matchResult) {\n    const parameterNode = resolveParentNode(diff, ctx);\n    if (!parameterNode) {\n      return FAILED_PARAMS_CALCULATION;\n    }\n    const commonParams = calculateCommonParams(matchResult, parameterNode);\n    return {\n      ...result,\n      ...commonParams\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_FIELD_IN_PARAMETER);\n  if (matchResult) {\n    const matchingDepth = calculateMatchingDepth(matchResult);\n    const propertyName = calculateChangedProperty(matchResult);\n    const parameterNode = resolveValueFromCompareContext(diff, ctx, ...calculateParentJumpDeep(matchResult.path.length - matchingDepth));\n    if (!parameterNode) {\n      return FAILED_PARAMS_CALCULATION;\n    }\n    const commonParams = calculateCommonParams(matchResult, parameterNode);\n    return {\n      ...result,\n      ...commonParams,\n      propertyName\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATHS_FOR_CHANGED_PARAMETER = [\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_PARAMETER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, PREDICATE_ANY_VALUE],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, PREDICATE_ANY_VALUE])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_FIELD_IN_PARAMETER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END])\n];\nconst requestParamsCalculator = (diff, _) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_REQUEST);\n  if (matchResult) {\n    return result;\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_FIELD_IN_REQUEST);\n  if (matchResult) {\n    let requestPath;\n    if (startFromOpenApiComponents(matchResult.path)) {\n      requestPath = calculateComponentsPath(matchResult);\n    }\n    return {\n      ...result,\n      requestPath\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATH_FOR_CHANGED_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY])\n];\nconst PREDICATES_PATH_FOR_CHANGED_FIELD_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, PREDICATE_ANY_VALUE])\n];\nconst responseParamsCalculator = (diff, _) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_RESPONSE);\n  if (matchResult) {\n    const responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    return {\n      ...result,\n      responseName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_FIELD_IN__RESPONSE);\n  if (matchResult) {\n    let componentPath;\n    let responseName;\n    if (startFromOpenApiComponents(matchResult.path)) {\n      componentPath = calculateComponentsPath(matchResult);\n    } else {\n      responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    }\n    return {\n      ...result,\n      componentPath,\n      responseName\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATH_FOR_CHANGED_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME)])\n];\nconst PREDICATES_PATH_FOR_CHANGED_FIELD_IN__RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), PREDICATE_ANY_VALUE])\n];\nconst contentParamsCalculator = (diff, _) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const calculateCommonParams = (matchResult2, place) => {\n    let componentPath;\n    let scope;\n    const mediaType = checkPrimitiveType(matchResult2.grepValues[GREP_TEMPLATE_PARAM_MEDIA_TYPE]);\n    if (startFromOpenApiComponents(matchResult2.path)) {\n      componentPath = calculateComponentsPath(matchResult2);\n    } else {\n      scope = place;\n    }\n    return { mediaType, componentPath, scope };\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_CONTENT_IN_REQUEST);\n  if (matchResult) {\n    const commonParams = calculateCommonParams(matchResult, \"request body\");\n    return {\n      ...result,\n      ...commonParams\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_CONTENT_IN_RESPONSE);\n  if (matchResult) {\n    const responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    const commonParams = calculateCommonParams(matchResult, \"response\");\n    return {\n      ...result,\n      ...commonParams,\n      responseName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_EXAMPLE_IN_CONTENT_IN_REQUEST);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const commonParams = calculateCommonParams(matchResult, \"request body\");\n    return {\n      ...result,\n      ...commonParams,\n      propertyName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATH_FOR_CHANGED_EXAMPLE_IN_CONTENT_IN_RESPONSE);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const responseName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    const commonParams = calculateCommonParams(matchResult, \"response\");\n    return {\n      ...result,\n      ...commonParams,\n      propertyName,\n      responseName\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATH_FOR_CHANGED_CONTENT_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE)])\n];\nconst PREDICATES_PATH_FOR_CHANGED_CONTENT_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE)])\n];\nconst PREDICATES_PATH_FOR_CHANGED_EXAMPLE_IN_CONTENT_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE]),\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATH_FOR_CHANGED_EXAMPLE_IN_CONTENT_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE]),\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END])\n];\nconst examplesParamsCalculator = (diff, ctx) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_EXAMPLES);\n  if (matchResult) {\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    return {\n      ...result,\n      exampleName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const examplePath = calculateComponentsPath(matchResult);\n    return {\n      ...result,\n      propertyName,\n      examplePath\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_PARAMETERS);\n  if (matchResult) {\n    const place = calculateParameterPlace(matchResult, diff, ctx);\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_REQUEST);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    const place = calculateRequestPlace(matchResult);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_RESPONSE);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    const place = calculateResponsePlace(matchResult);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_HEADER);\n  if (matchResult) {\n    const place = calculateHeaderPlace(matchResult);\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_HEADER_IN_RESPONSE);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    const place = calculateHeaderPlace(matchResult);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_ENCODING_IN_HEADER_IN_RESPONSE);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    const place = calculateEncodingPlaceInResponse(matchResult);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_ENCODING_IN_HEADER_IN_REQUEST);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult, true);\n    const exampleName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_EXAMPLE_NAME]);\n    const place = calculateEncodingPlaceInRequest(matchResult);\n    return {\n      ...result,\n      propertyName,\n      exampleName,\n      place\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATHS_FOR_CHANGED_EXAMPLES = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)]),\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)]),\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)]),\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_HEADERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_HEADERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_EXAMPLES, PREDICATE_ANY_VALUE, PREDICATE_UNCLOSED_END]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_PARAMETERS = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END],\n  [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_PARAMETERS, grepValue(GREP_TEMPLATE_PARAM_PARAMETER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_HEADER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_HEADER_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_ENCODING_IN_HEADER_IN_RESPONSE = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLES_IN_ENCODING_IN_HEADER_IN_REQUEST = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_REQUEST_BODIES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_REQUEST_BODY, OPEN_API_PROPERTY_CONTENT, grepValue(GREP_TEMPLATE_PARAM_MEDIA_TYPE), OPEN_API_PROPERTY_ENCODING, grepValue(GREP_TEMPLATE_PARAM_ENCODING_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLES, grepValue(GREP_TEMPLATE_PARAM_EXAMPLE_NAME), PREDICATE_UNCLOSED_END])\n];\nconst headerParamsCalculator = (diff, _) => {\n  const result = {\n    action: DIFF_ACTION_TO_ACTION_MAP[diff.action],\n    preposition: DIFF_ACTION_TO_PREPOSITION_MAP[diff.action]\n  };\n  const calculateResponseCaseParams = (matchResult2) => {\n    let responseName;\n    let responsePath;\n    const headerName = checkPrimitiveType(matchResult2.grepValues[GREP_TEMPLATE_PARAM_HEADER_NAME]);\n    if (startFromOpenApiComponents(matchResult2.path)) {\n      responsePath = calculateComponentsPath(matchResult2);\n    } else {\n      responseName = checkPrimitiveType(matchResult2.grepValues[GREP_TEMPLATE_PARAM_RESPONSE_NAME]);\n    }\n    return { headerName, responsePath, responseName };\n  };\n  const declarationPaths = resolveAllDeclarationPath(diff);\n  let matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_HEADER);\n  if (matchResult) {\n    const headerName = checkPrimitiveType(matchResult.grepValues[GREP_TEMPLATE_PARAM_HEADER_NAME]);\n    return {\n      ...result,\n      headerName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_HEADER_IN_COMPONENTS);\n  if (matchResult) {\n    const headerPath = calculateComponentsPath(matchResult);\n    return {\n      ...result,\n      headerPath\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_HEADER_IN_RESPONSES);\n  if (matchResult) {\n    const responseParams = calculateResponseCaseParams(matchResult);\n    return {\n      ...result,\n      ...responseParams\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_IN_HEADER_IN_COMPONENTS);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const headerPath = calculateComponentsPath(matchResult);\n    return {\n      ...result,\n      headerPath,\n      propertyName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_IN_HEADER_IN_RESPONSES);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const responseParams = calculateResponseCaseParams(matchResult);\n    return {\n      ...result,\n      ...responseParams,\n      propertyName\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_RESPONSE);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const place = calculateEncodingPlaceInResponse(matchResult);\n    return {\n      ...result,\n      propertyName,\n      place\n    };\n  }\n  matchResult = matchPaths(declarationPaths, PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_ENCODING_IN_HEADER_IN_REQUEST);\n  if (matchResult) {\n    const propertyName = calculateChangedProperty(matchResult);\n    const place = calculateEncodingPlaceInRequest(matchResult);\n    return {\n      ...result,\n      propertyName,\n      place\n    };\n  }\n  return result;\n};\nconst PREDICATES_PATHS_FOR_CHANGED_HEADER = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME)],\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME)],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME)])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_HEADER_IN_COMPONENTS = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, PREDICATE_ANY_VALUE, PREDICATE_ANY_VALUE]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_HEADER_IN_RESPONSES = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_ANY_VALUE],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_ANY_VALUE])\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_IN_HEADER_IN_COMPONENTS = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_HEADERS, PREDICATE_ANY_VALUE, OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END]\n];\nconst PREDICATES_PATHS_FOR_CHANGED_FIELD_IN_EXAMPLE_IN_HEADER_IN_RESPONSES = [\n  [OPEN_API_PROPERTY_COMPONENTS, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), OPEN_API_PROPERTY_EXAMPLE, PREDICATE_UNCLOSED_END],\n  ...OPEN_API_HTTP_METHODS.map((httpMethod) => [OPEN_API_PROPERTY_PATHS, PREDICATE_ANY_VALUE, httpMethod, OPEN_API_PROPERTY_RESPONSES, grepValue(GREP_TEMPLATE_PARAM_RESPONSE_NAME), OPEN_API_PROPERTY_HEADERS, grepValue(GREP_TEMPLATE_PARAM_HEADER_NAME), PREDICATE_ANY_VALUE, PREDICATE_UNCLOSED_END])\n];\nconst documentAnnotationRule = { $: allAnnotation };\nconst operationAnnotationRule = { $: allAnnotation };\nconst openApi3Rules = (options) => {\n  const requestSchemaRules = openApiSchemaRules(options);\n  const responseSchemaRules = openApiSchemaRules({ ...options, response: true });\n  const serversRules = {\n    $: allAnnotation,\n    \"/*\": {\n      \"/variables\": {\n        \"/*\": {\n          \"/enum\": {\n            mapping: deepEqualsUniqueItemsArrayMappingResolver,\n            \"/*\": { ignoreKeyDifference: true }\n          },\n          ...openApiSpecificationExtensionRulesFunction()\n        }\n      },\n      ...openApiSpecificationExtensionRulesFunction()\n    },\n    \"/**\": {\n      $: allAnnotation\n    }\n  };\n  const externalDocumentationRules = {\n    $: allAnnotation,\n    ...openApiSpecificationExtensionRulesFunction(allAnnotation),\n    \"/*\": {\n      $: allAnnotation\n    }\n  };\n  const examplesRules = {\n    $: allAnnotation,\n    \"/*\": {\n      $: allAnnotation,\n      description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] example '{{${GREP_TEMPLATE_PARAM_EXAMPLE_NAME}}}'`),\n      descriptionParamCalculator: examplesParamsCalculator,\n      \"/description\": {\n        $: allAnnotation,\n        description: diffDescription(resolveExamplesDescriptionTemplates())\n      },\n      \"/externalValue\": {\n        $: allAnnotation,\n        description: diffDescription(resolveExamplesDescriptionTemplates())\n      },\n      \"/summary\": {\n        $: allAnnotation,\n        description: diffDescription(resolveExamplesDescriptionTemplates())\n      },\n      \"/value\": {\n        $: allAnnotation,\n        description: diffDescription(resolveExamplesDescriptionTemplates()),\n        \"/**\": {\n          $: allAnnotation,\n          description: diffDescription(resolveExamplesDescriptionTemplates())\n        }\n      },\n      ...openApiSpecificationExtensionRulesFunction(allAnnotation)\n    },\n    \"/**\": { $: allAnnotation }\n  };\n  const parametersRules = {\n    \"/*\": {\n      $: paramClassifyRule,\n      description: diffDescription([`[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PARAMETER_LOCATION}}} parameter '{{${GREP_TEMPLATE_PARAM_PARAMETER_NAME}}}'`]),\n      descriptionParamCalculator: parameterParamsCalculator,\n      [IGNORE_DIFFERENCE_IN_KEYS_RULE]: true,\n      [START_NEW_COMPARE_SCOPE_RULE]: COMPARE_SCOPE_REQUEST,\n      \"/allowEmptyValue\": {\n        $: apihubAllowEmptyValueParameterClassifyRule,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"allowEmptyValue status\"))\n      },\n      \"/allowReserved\": {\n        $: parameterAllowReservedClassifyRule,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"allowReserved status\"))\n      },\n      \"/deprecated\": {\n        $: allDeprecated,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"deprecated status\"))\n      },\n      \"/description\": {\n        $: allAnnotation,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"description\"))\n      },\n      \"/example\": {\n        $: allAnnotation,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"example\")),\n        \"/**\": {\n          $: allAnnotation,\n          description: diffDescription(resolveParameterDescriptionTemplates())\n        }\n      },\n      \"/examples\": examplesRules,\n      \"/explode\": {\n        $: parameterExplodeClassifyRule,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"explode status\"))\n      },\n      \"/in\": {\n        $: [nonBreaking, breaking, breaking],\n        description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PARAMETER_LOCATION}}} parameter '{{${GREP_TEMPLATE_PARAM_PARAMETER_NAME}}}'`)\n      },\n      \"/name\": {\n        $: parameterNameClassifyRule,\n        description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PARAMETER_LOCATION}}} parameter '{{${GREP_TEMPLATE_PARAM_PARAMETER_NAME}}}'`)\n      },\n      \"/required\": {\n        $: parameterRequiredClassifyRule,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"required status\"))\n      },\n      \"/schema\": () => ({\n        $: allBreaking,\n        ...requestSchemaRules\n      }),\n      \"/style\": {\n        $: allBreaking,\n        description: diffDescription(resolveParameterDescriptionTemplates(\"delimited style\"))\n      },\n      ...openApiSpecificationExtensionRulesFunction()\n    }\n  };\n  const headersRules = {\n    $: [nonBreaking, breaking, breaking],\n    \"/*\": {\n      $: [nonBreaking, breaking, breaking],\n      description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] header '{{${GREP_TEMPLATE_PARAM_HEADER_NAME}}}'`),\n      descriptionParamCalculator: headerParamsCalculator,\n      \"/allowEmptyValue\": {\n        $: allUnclassified,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"allowEmptyValue status\"))\n      },\n      \"/allowReserved\": {\n        $: allUnclassified,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"allowReserved status\"))\n      },\n      \"/deprecated\": {\n        $: allDeprecated,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"deprecated status\"))\n      },\n      \"/description\": {\n        $: allAnnotation,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"description\"))\n      },\n      \"/example\": {\n        $: allUnclassified,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"example\")),\n        \"/**\": {\n          $: allUnclassified,\n          description: diffDescription(resolveHeaderDescriptionTemplates())\n        }\n      },\n      \"/examples\": examplesRules,\n      \"/explode\": {\n        $: allUnclassified,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"explode status\"))\n      },\n      \"/required\": {\n        $: [breaking, nonBreaking, breakingIfAfterTrue],\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"required status\"))\n      },\n      \"/schema\": ({ path }) => ({\n        $: allBreaking,\n        ...isResponseSchema(path) ? responseSchemaRules : requestSchemaRules\n      }),\n      \"/style\": {\n        $: allUnclassified,\n        description: diffDescription(resolveHeaderDescriptionTemplates(\"delimited style\"))\n      },\n      ...openApiSpecificationExtensionRulesFunction()\n    }\n  };\n  const encodingRules = {\n    $: [breaking, nonBreaking, breaking],\n    descriptionParamCalculator: encodingParamsCalculator,\n    \"/*\": {\n      description: diffDescription(resolveEncodingDescriptionTemplates()),\n      \"/allowReserved\": {\n        $: [nonBreaking, breaking, breaking],\n        description: diffDescription(resolveEncodingDescriptionTemplates())\n      },\n      \"/contentType\": {\n        $: [nonBreaking, breaking, breaking],\n        description: diffDescription(resolveEncodingDescriptionTemplates())\n      },\n      \"/explode\": {\n        $: [nonBreaking, breaking, breaking],\n        description: diffDescription(resolveEncodingDescriptionTemplates())\n      },\n      \"/headers\": headersRules,\n      \"/style\": {\n        $: [nonBreaking, breaking, breaking],\n        description: diffDescription(resolveEncodingDescriptionTemplates())\n      },\n      ...openApiSpecificationExtensionRulesFunction()\n    }\n  };\n  const contentRules = {\n    $: [nonBreaking, breaking, breaking],\n    mapping: contentMediaTypeMappingResolver,\n    \"/*\": {\n      $: [nonBreaking, breaking, nonBreaking],\n      description: diffDescription([\n        `[{{${TEMPLATE_PARAM_ACTION}}}] '{{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}}' media type {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}} '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}'`,\n        `[{{${TEMPLATE_PARAM_ACTION}}}] '{{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}}' media type {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_COMPONENT_PATH}}}'`,\n        `[{{${TEMPLATE_PARAM_ACTION}}}] '{{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}}' media type {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}}`\n      ]),\n      descriptionParamCalculator: contentParamsCalculator,\n      \"/encoding\": encodingRules,\n      \"/example\": {\n        $: allAnnotation,\n        description: diffDescription([\n          `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}} '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}' ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`,\n          `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_COMPONENT_PATH}}}' ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`,\n          `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}} ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`\n        ]),\n        \"/**\": {\n          $: allAnnotation,\n          description: diffDescription([\n            `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}} '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}' ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`,\n            `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_COMPONENT_PATH}}}' ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`,\n            `[{{${TEMPLATE_PARAM_ACTION}}}] {{${TEMPLATE_PARAM_PROPERTY_NAME}}} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_SCOPE}}} ({{${GREP_TEMPLATE_PARAM_MEDIA_TYPE}}})`\n          ])\n        }\n      },\n      \"/examples\": examplesRules,\n      \"/schema\": ({ path }) => ({\n        $: allBreaking,\n        ...isResponseSchema(path) ? responseSchemaRules : requestSchemaRules\n      }),\n      ...openApiSpecificationExtensionRulesFunction()\n    }\n  };\n  const requestBodiesRules = {\n    $: [nonBreaking, breaking, breaking],\n    description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] request body`),\n    descriptionParamCalculator: requestParamsCalculator,\n    [START_NEW_COMPARE_SCOPE_RULE]: COMPARE_SCOPE_REQUEST,\n    \"/content\": contentRules,\n    \"/description\": {\n      $: allAnnotation,\n      description: diffDescription(resolveRequestDescriptionTemplates(\"description\"))\n    },\n    \"/required\": {\n      $: [breaking, nonBreaking, breakingIfAfterTrue],\n      description: diffDescription(resolveRequestDescriptionTemplates(\"required status\"))\n    },\n    ...openApiSpecificationExtensionRulesFunction()\n  };\n  const responseRules = {\n    $: [nonBreaking, breaking, (ctx) => nonBreakingIf(ctx.before.key.toString().toLocaleLowerCase() === ctx.after.key.toString().toLocaleLowerCase())],\n    description: diffDescription(`[{{${TEMPLATE_PARAM_ACTION}}}] response '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}'`),\n    descriptionParamCalculator: responseParamsCalculator,\n    \"/content\": contentRules,\n    \"/description\": {\n      $: allAnnotation,\n      description: diffDescription([\n        `[{{${TEMPLATE_PARAM_ACTION}}}] description {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_COMPONENT_PATH}}}'`,\n        `[{{${TEMPLATE_PARAM_ACTION}}}] description {{${TEMPLATE_PARAM_PREPOSITION}}} response '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}'`\n      ])\n    },\n    \"/headers\": headersRules,\n    ...openApiSpecificationExtensionRulesFunction()\n  };\n  const operationRule = {\n    $: [nonBreaking, breaking, unclassified],\n    \"/callbacks\": {\n      \"/*\": {\n        //no support?\n      }\n    },\n    \"/deprecated\": { $: allDeprecated },\n    \"/externalDocs\": externalDocumentationRules,\n    \"/parameters\": {\n      $: [nonBreaking, apihubParametersRemovalClassifyRule, breaking],\n      mapping: paramMappingResolver(2),\n      ...parametersRules\n    },\n    \"/requestBody\": requestBodiesRules,\n    \"/responses\": {\n      $: [nonBreaking, breaking, breaking],\n      [START_NEW_COMPARE_SCOPE_RULE]: COMPARE_SCOPE_RESPONSE,\n      mapping: apihubCaseInsensitiveKeyMappingResolver,\n      ...openApiSpecificationExtensionRulesFunction(),\n      \"/*\": responseRules\n    },\n    \"/security\": {\n      $: operationSecurityClassifyRule,\n      \"/*\": {\n        $: operationSecurityItemClassifyRule,\n        \"/*\": {\n          $: allBreaking,\n          mapping: deepEqualsUniqueItemsArrayMappingResolver,\n          \"/*\": {\n            $: [breaking, nonBreaking, breaking],\n            ignoreKeyDifference: true\n          }\n        }\n      }\n    },\n    \"/servers\": serversRules,\n    \"/tags\": {\n      ...operationAnnotationRule,\n      mapping: deepEqualsUniqueItemsArrayMappingResolver,\n      \"/*\": {\n        ...operationAnnotationRule,\n        [IGNORE_DIFFERENCE_IN_KEYS_RULE]: true\n      }\n    },\n    ...openApiSpecificationExtensionRulesFunction(),\n    \"/*\": operationAnnotationRule\n  };\n  const oAuthFlowObjectRules = {\n    $: [breaking, nonBreaking, breaking],\n    ...openApiSpecificationExtensionRulesFunction()\n  };\n  const oAuthFlowsObjectRules = {\n    $: [breaking, nonBreaking, breaking],\n    ...openApiSpecificationExtensionRulesFunction(),\n    \"/*\": oAuthFlowObjectRules\n  };\n  const tagObjectCompareRules = {\n    $: allAnnotation,\n    \"/externalDocs\": externalDocumentationRules,\n    ...openApiSpecificationExtensionRulesFunction(allAnnotation),\n    \"/*\": { $: allAnnotation }\n  };\n  const pathItemObjectRules = (options2) => ({\n    $: pathChangeClassifyRule,\n    mapping: options2.mode === COMPARE_MODE_OPERATION ? singleOperationPathMappingResolver : methodMappingResolver,\n    \"/description\": { $: allAnnotation },\n    \"/parameters\": {\n      $: [nonBreaking, breaking, breaking],\n      mapping: paramMappingResolver(1),\n      ...parametersRules\n    },\n    \"/servers\": serversRules,\n    \"/summary\": { $: allAnnotation },\n    ...openApiSpecificationExtensionRulesFunction(),\n    \"/*\": operationRule\n  });\n  const componentsRule = {\n    $: allNonBreaking,\n    [START_NEW_COMPARE_SCOPE_RULE]: COMPARE_SCOPE_COMPONENTS,\n    \"/examples\": examplesRules,\n    \"/headers\": headersRules,\n    \"/parameters\": {\n      $: [nonBreaking, breaking, breaking],\n      ...parametersRules\n    },\n    \"/requestBodies\": {\n      $: [nonBreaking, breaking, breaking],\n      \"/*\": requestBodiesRules\n    },\n    \"/responses\": {\n      $: [nonBreaking, breaking, breaking],\n      \"/*\": responseRules\n    },\n    \"/schemas\": {\n      $: [nonBreaking, breaking, breaking],\n      \"/*\": () => ({\n        $: allUnclassified,\n        /*for mode One operation*/\n        ...requestSchemaRules\n      })\n    },\n    \"/pathItems\": {\n      $: [nonBreaking, breaking, breaking],\n      \"/*\": pathItemObjectRules(options)\n    },\n    \"/securitySchemes\": {\n      $: [breaking, nonBreaking, breaking],\n      \"/*\": {\n        $: [breaking, nonBreaking, breaking],\n        \"/bearerFormat\": { $: allAnnotation },\n        \"/description\": { $: allAnnotation },\n        \"/flows\": oAuthFlowsObjectRules,\n        \"/in\": { $: [breaking, nonBreaking, breaking] },\n        \"/name\": { $: [breaking, nonBreaking, breaking] },\n        \"/openIdConnectUrl\": { $: allAnnotation },\n        \"/scheme\": { $: [breaking, nonBreaking, breaking] },\n        \"/type\": { $: [breaking, nonBreaking, breaking] },\n        ...openApiSpecificationExtensionRulesFunction()\n      }\n    },\n    ...openApiSpecificationExtensionRulesFunction()\n  };\n  return {\n    ...openApiSpecificationExtensionRulesFunction(),\n    \"/openapi\": documentAnnotationRule,\n    \"/info\": {\n      ...documentAnnotationRule,\n      ...openApiSpecificationExtensionRulesFunction(allAnnotation),\n      \"/contact\": {\n        ...openApiSpecificationExtensionRulesFunction(allAnnotation)\n      },\n      \"/license\": {\n        ...openApiSpecificationExtensionRulesFunction(allAnnotation)\n      },\n      \"/**\": documentAnnotationRule\n    },\n    \"/servers\": serversRules,\n    \"/paths\": {\n      $: allUnclassified,\n      mapping: options.mode === COMPARE_MODE_OPERATION ? singleOperationPathMappingResolver : pathMappingResolver,\n      \"/*\": pathItemObjectRules(options),\n      ...openApiSpecificationExtensionRulesFunction()\n    },\n    \"/components\": componentsRule,\n    \"/security\": {\n      $: globalSecurityClassifyRule,\n      \"/*\": { $: globalSecurityItemClassifyRule }\n    },\n    \"/tags\": {\n      $: allAnnotation,\n      \"/*\": tagObjectCompareRules\n    },\n    \"/externalDocs\": externalDocumentationRules\n  };\n};\nconst resolveHeaderDescriptionTemplates = (details = `{{${TEMPLATE_PARAM_PROPERTY_NAME}}}`) => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} header '{{${GREP_TEMPLATE_PARAM_HEADER_NAME}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} header '{{${GREP_TEMPLATE_PARAM_HEADER_NAME}}}' in response '{{${GREP_TEMPLATE_PARAM_RESPONSE_NAME}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} header '{{${GREP_TEMPLATE_PARAM_HEADER_NAME}}}' in '{{${TEMPLATE_PARAM_RESPONSE_PATH}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_HEADER_PATH}}}'`\n];\nconst resolveParameterDescriptionTemplates = (details = `{{${TEMPLATE_PARAM_PROPERTY_NAME}}}`) => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_PARAMETER_LOCATION}}} parameter '{{${TEMPLATE_PARAM_PARAMETER_PATH}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} {{${TEMPLATE_PARAM_PARAMETER_LOCATION}}} parameter '{{${GREP_TEMPLATE_PARAM_PARAMETER_NAME}}}'`\n];\nconst resolveRequestDescriptionTemplates = (details = `{{${TEMPLATE_PARAM_PROPERTY_NAME}}}`) => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${TEMPLATE_PARAM_REQUEST_PATH}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} request body`\n];\nconst resolveExamplesDescriptionTemplates = (details = `{{${TEMPLATE_PARAM_PROPERTY_NAME}}}`) => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} example '{{${TEMPLATE_PARAM_EXAMPLE_PATH}}}'`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] ${details} {{${TEMPLATE_PARAM_PREPOSITION}}} example '{{${GREP_TEMPLATE_PARAM_EXAMPLE_NAME}}}' {{${TEMPLATE_PARAM_PLACE}}}`\n];\nconst resolveEncodingDescriptionTemplates = () => [\n  `[{{${TEMPLATE_PARAM_ACTION}}}] Encoding details {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${GREP_TEMPLATE_PARAM_ENCODING_NAME}}}' {{${TEMPLATE_PARAM_PLACE}}}`,\n  `[{{${TEMPLATE_PARAM_ACTION}}}] Encoding details ({{${TEMPLATE_PARAM_PROPERTY_NAME}}}) {{${TEMPLATE_PARAM_PREPOSITION}}} '{{${GREP_TEMPLATE_PARAM_ENCODING_NAME}}}' {{${TEMPLATE_PARAM_PLACE}}}`\n];\nconst compareOpenApi = (version) => (before, after, options) => {\n  return compare(\n    before,\n    after,\n    {\n      ...options,\n      rules: openApi3Rules({\n        mode: options.mode,\n        version\n      })\n    }\n  );\n};\nfunction isOpenApiSpecVersion(specType) {\n  return specType === SPEC_TYPE_OPEN_API_30 || specType === SPEC_TYPE_OPEN_API_31;\n}\nfunction areSpecTypesCompatible(beforeType, afterType) {\n  if (beforeType === afterType) {\n    return true;\n  }\n  return isOpenApiSpecVersion(beforeType) && isOpenApiSpecVersion(afterType);\n}\nfunction selectEngineSpecType(beforeType, afterType) {\n  if (isOpenApiSpecVersion(beforeType) && isOpenApiSpecVersion(afterType)) {\n    if (beforeType === SPEC_TYPE_OPEN_API_31 || afterType === SPEC_TYPE_OPEN_API_31) {\n      return SPEC_TYPE_OPEN_API_31;\n    }\n    return SPEC_TYPE_OPEN_API_30;\n  }\n  return beforeType;\n}\nconst COMPARE_ENGINES_MAP = {\n  [SPEC_TYPE_JSON_SCHEMA_04]: compareJsonSchema(SPEC_TYPE_JSON_SCHEMA_04),\n  [SPEC_TYPE_JSON_SCHEMA_06]: compareJsonSchema(SPEC_TYPE_JSON_SCHEMA_06),\n  [SPEC_TYPE_JSON_SCHEMA_07]: compareJsonSchema(SPEC_TYPE_JSON_SCHEMA_07),\n  [SPEC_TYPE_OPEN_API_30]: compareOpenApi(SPEC_TYPE_OPEN_API_30),\n  [SPEC_TYPE_OPEN_API_31]: compareOpenApi(SPEC_TYPE_OPEN_API_31),\n  [SPEC_TYPE_ASYNCAPI_2]: compareAsyncApi,\n  [SPEC_TYPE_GRAPH_API]: compareGraphApi\n};\nfunction apiDiff(before, after, options = {}) {\n  const beforeSpec = resolveSpec(before);\n  const afterSpec = resolveSpec(after);\n  if (!areSpecTypesCompatible(beforeSpec.type, afterSpec.type)) {\n    throw new Error(`Specification cannot be different. Got ${beforeSpec.type} and ${afterSpec.type}`);\n  }\n  const engine = COMPARE_ENGINES_MAP[selectEngineSpecType(beforeSpec.type, afterSpec.type)];\n  return engine(before, after, {\n    mode: COMPARE_MODE_DEFAULT,\n    normalizedResult: DEFAULT_NORMALIZED_RESULT,\n    metaKey: DIFF_META_KEY,\n    defaultsFlag: DEFAULT_OPTION_DEFAULTS_META_KEY,\n    originsFlag: DEFAULT_OPTION_ORIGINS_META_KEY,\n    compareScope: COMPARE_SCOPE_ROOT,\n    mergedJsoCache: createEvaluationCacheService(),\n    diffUniquenessCache: createEvaluationCacheService(),\n    valueAdaptationCache: createEvaluationCacheService(),\n    createdMergedJso: /* @__PURE__ */ new Set(),\n    ...options\n  });\n}\nexport {\n  ApiCompatibilityKind,\n  COMPARE_MODE_DEFAULT,\n  COMPARE_MODE_OPERATION,\n  ClassifierType,\n  DIFFS_AGGREGATED_META_KEY,\n  DIFF_META_KEY,\n  DiffAction,\n  aggregateDiffsWithRollup,\n  annotation,\n  apiDiff,\n  breaking,\n  deprecated,\n  extractOperationBasePath,\n  isDiffAdd,\n  isDiffRemove,\n  isDiffRename,\n  isDiffReplace,\n  nonBreaking,\n  onlyExistedArrayIndexes,\n  risky,\n  unclassified\n};\n//# sourceMappingURL=index.es.js.map\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChangeSummary, DiffTypeDto } from '@netcracker/qubership-apihub-api-processor'\nimport {\n  annotation,\n  breaking,\n  deprecated,\n  nonBreaking,\n  unclassified,\n  risky,\n} from '@netcracker/qubership-apihub-api-diff'\nimport type {\n  DiffType,\n} from '@netcracker/qubership-apihub-api-diff'\nimport type { Color } from '../utils/types'\n\nexport const ADD_ACTION_TYPE = 'add'\nexport const REMOVE_ACTION_TYPE = 'remove'\nexport const REPLACE_ACTION_TYPE = 'replace'\nexport const RENAME_ACTION_TYPE = 'rename'\n\n// TODO: Use from builder\nexport type ActionType =\n  | typeof ADD_ACTION_TYPE\n  | typeof REMOVE_ACTION_TYPE\n  | typeof REPLACE_ACTION_TYPE\n  | typeof RENAME_ACTION_TYPE\n\nexport const BREAKING_CHANGE_SEVERITY = breaking\nexport const NON_BREAKING_CHANGE_SEVERITY = nonBreaking\nexport const RISKY_CHANGE_SEVERITY = risky\nexport const DEPRECATED_CHANGE_SEVERITY = deprecated\nexport const ANNOTATION_CHANGE_SEVERITY = annotation\nexport const UNCLASSIFIED_CHANGE_SEVERITY = unclassified\n\nexport type ChangesSummary<T extends DiffType | DiffTypeDto = DiffType> = ChangeSummary<T>\n\nexport type ChangeSeverity<T = DiffType> = T\n\n// TODO 12.09.25 // [Tech Debt] Extract all colors to constants and/or CSS variables, then map MUI custom variants to colors\nexport const CHANGE_SEVERITY_COLOR_MAP: Record<ChangeSeverity, string> = {\n  [breaking]: '#ED4A54',\n  [risky]: '#E98554',\n  [deprecated]: '#FFB02E',\n  [nonBreaking]: '#6BCE70',\n  [unclassified]: '#61AAF2',\n  [annotation]: '#C55DCF',\n}\n\nexport const CHANGE_SEVERITY_NAME_MAP: Record<ChangeSeverity, string> = {\n  [breaking]: 'Breaking',\n  [risky]: 'Requires Attention',\n  [deprecated]: 'Deprecated',\n  [nonBreaking]: 'Non-breaking',\n  [unclassified]: 'Unclassified',\n  [annotation]: 'Annotation',\n}\n\nexport const CHANGE_SEVERITY_TOOLTIP_TITLE_MAP: Record<ChangeSeverity, string> = {\n  [breaking]: 'Breaking Changes',\n  [risky]: 'Changes Requiring Attention',\n  [deprecated]: 'Deprecated Changes',\n  [nonBreaking]: 'Non-breaking Changes',\n  [unclassified]: 'Unclassified Changes',\n  [annotation]: 'Annotation Changes',\n}\n\nexport const CHANGE_SEVERITY_DESCRIPTION_MAP: Record<ChangeSeverity, string> = {\n  [breaking]: 'Breaking change is a change that breaks backward compatibility with the previous version of API. For example, deleting an operation, adding a required parameter or changing type of a parameter are breaking changes.',\n  [risky]: 'A change requiring attention is a change that potentially may break backward compatibility with the previous version of API, depending on the particular implementation of a client code. This category also includes breaking changes in operations annotated as no-BWC.',\n  [deprecated]: 'Deprecating change is a change that annotates an operation, parameter or schema as deprecated. Removing a \"deprecated\" annotation is also considered a deprecating change.',\n  [nonBreaking]: 'Non-breaking change is change that does not break backward compatibility with the previous version of API. For example, adding new operation or optional parameter is non-breaking change.',\n  [unclassified]: 'An unclassified change is a change that cannot be classified as any of the other types.',\n  [annotation]: 'An annotation change is a change to enrich the API documentation with information that does not affect the functionality of the API. For example, adding/changing/deleting descriptions or examples is annotation change.',\n}\n\nexport const CHANGE_SEVERITIES: ReadonlySet<ChangeSeverity> = new Set([\n    breaking,\n    risky,\n    deprecated,\n    nonBreaking,\n    unclassified,\n    annotation,\n  ],\n)\n\nexport const ACTION_TYPE_COLOR_MAP: Partial<Record<ActionType, Color>> = {\n  [ADD_ACTION_TYPE]: 'rgba(0,187,91,0.08)',\n  [REMOVE_ACTION_TYPE]: '#FFF1F2',\n  [REPLACE_ACTION_TYPE]: '#FFF9EE',\n}\n\nexport const DEFAULT_CHANGE_SEVERITY_MAP = {\n  [breaking]: 0,\n  [risky]: 0,\n  [deprecated]: 0,\n  [nonBreaking]: 0,\n  [unclassified]: 0,\n  [annotation]: 0,\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Box, Divider, Tooltip } from '@mui/material'\nimport type { PropsWithChildren, ReactElement } from 'react'\n\nexport type MarkerTooltipProps<V extends string = string, C extends string = string> = PropsWithChildren<{\n  variant: V\n  variantToDescription: Record<V, string>\n  variantToTooltipTitle: Record<V, string>\n  variantToColor: Record<V, string>\n  disableHoverListener?: boolean\n  category?: C\n  categoryToTooltipTitle?: Partial<Record<C, string>> // should be garanteed when category is provided\n}>\n\nexport const MarkerTooltip = <\n  V extends string,\n  C extends string = string,\n>(props: MarkerTooltipProps<V, C>): ReactElement => {\n  const {\n    children,\n    variant,\n    variantToDescription,\n    variantToTooltipTitle,\n    variantToColor,\n    disableHoverListener = false,\n    category,\n    categoryToTooltipTitle,\n  } = props\n\n  return (\n    <Tooltip\n      title={\n        <MarkerTooltipContent<V, C>\n          variant={variant}\n          variantToDescription={variantToDescription}\n          variantToTooltipTitle={variantToTooltipTitle}\n          variantToColor={variantToColor}\n          category={category}\n          categoryToTooltipTitle={categoryToTooltipTitle}\n        />\n      }\n      placement=\"bottom-end\"\n      disableHoverListener={disableHoverListener}\n    >\n      <Box>\n        {children}\n      </Box>\n    </Tooltip>\n  )\n}\n\ntype MarkerTooltipContentProps<V extends string, C extends string> = {\n  variant: V\n  variantToDescription: Record<V, string>\n  variantToTooltipTitle: Record<V, string>\n  variantToColor: Record<V, string>\n  category?: C\n  categoryToTooltipTitle?: Partial<Record<C, string>>\n}\n\nconst MarkerTooltipContent = <\n  V extends string,\n  C extends string,\n>(props: MarkerTooltipContentProps<V, C>): ReactElement => {\n  const {\n    variant,\n    variantToDescription,\n    variantToTooltipTitle,\n    variantToColor,\n    category,\n    categoryToTooltipTitle,\n  } = props\n\n  const tooltipContent = variantToDescription[variant]\n  const categoryTitle = `${category ? `${categoryToTooltipTitle![category]} with ` : ''}${variantToTooltipTitle[variant]}`\n\n  return (\n    <Box sx={{ p: '4px 4px' }}>\n      <Box display=\"flex\" alignItems=\"center\">\n        <Box\n          component=\"span\"\n          sx={{\n            backgroundColor: variantToColor[variant],\n            width: 8,\n            height: 8,\n            borderRadius: '50%',\n            mr: 1,\n          }}\n        />\n        {categoryTitle}\n      </Box>\n      <Divider sx={{ mx: 0, mt: 1, mb: 1 }} orientation=\"horizontal\" />\n      <Box>\n        {tooltipContent}\n      </Box>\n    </Box>\n  )\n}\n","/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { FC, PropsWithChildren } from 'react'\nimport { memo } from 'react'\nimport type { ChangeSeverity } from '../entities/change-severities'\nimport {\n  CHANGE_SEVERITY_COLOR_MAP,\n  CHANGE_SEVERITY_DESCRIPTION_MAP,\n  CHANGE_SEVERITY_TOOLTIP_TITLE_MAP,\n} from '../entities/change-severities'\nimport { MarkerTooltip } from './MarkerTooltip'\n\nexport type ChangesTooltipProps = PropsWithChildren<{\n  changeType: ChangeSeverity\n  disableHoverListener?: boolean\n  category?: ChangesTooltipCategory\n}>\n\nexport const ChangesTooltip: FC<ChangesTooltipProps> = memo<ChangesTooltipProps>(props => {\n  const {\n    children,\n    changeType,\n    disableHoverListener = false,\n    category,\n  } = props\n\n  return (\n    <MarkerTooltip<ChangeSeverity, ChangesTooltipCategory>\n      disableHoverListener={disableHoverListener}\n      variant={changeType}\n      variantToDescription={CHANGE_SEVERITY_DESCRIPTION_MAP}\n      variantToTooltipTitle={CHANGE_SEVERITY_TOOLTIP_TITLE_MAP}\n      variantToColor={CHANGE_SEVERITY_COLOR_MAP}\n      category={category}\n      categoryToTooltipTitle={TOOLTIP_TITLE_BY_CATEGORY}\n    >\n      {children}\n    </MarkerTooltip>\n  )\n})\n\nexport const CATEGORY_OPERATION = 'operation'\nexport const CATEGORY_PACKAGE = 'packages'\n\nconst TOOLTIP_TITLE_BY_CATEGORY = {\n  [CATEGORY_OPERATION]: 'Operations',\n  [CATEGORY_PACKAGE]: 'Packages',\n}\n\nexport type ChangesTooltipCategory =\n  | typeof CATEGORY_OPERATION\n  | typeof CATEGORY_PACKAGE\n"],"names":["createDefaultIsNestedEqual","comparator","a","b","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB","meta","createIsCircular","areItemsEqual","isEqual","cache","cachedA","cachedB","result","merge","merged","key","isPlainObject","value","isPromiseLike","sameValueZeroEqual","ARGUMENTS_TAG","BOOLEAN_TAG","DATE_TAG","REG_EXP_TAG","MAP_TAG","NUMBER_TAG","OBJECT_TAG","SET_TAG","STRING_TAG","toString","createComparator","_a","areArraysEqual","areDatesEqual","areMapsEqual","areObjectsEqual","areRegExpsEqual","areSetsEqual","createIsNestedEqual","aArray","bArray","aTag","index","areArraysEqualCircular","isValueEqual","matchedIndices","indexA","aValue","aKey","hasMatch","matchIndexB","bValue","bKey","areMapsEqualCircular","OWNER","hasOwnProperty","keysA","reactElementA","reactElementB","areObjectsEqualCircular","matchIndex","areSetsEqualCircular","DEFAULT_CONFIG","DEFAULT_CIRCULAR_CONFIG","isDeepEqual","deepEqual","FAILED_PARAMS_CALCULATION","ApiCompatibilityKind","ApiCompatibilityKind2","isObject","isArray","isEmptyArray","isString","isSymbol","isFunc","objectKeys","getKeyValue","obj","path","onlyExistedArrayIndexes","array","anyArrayKeys","DiffAction","ClassifierType","breaking","nonBreaking","risky","unclassified","annotation","deprecated","allBreaking","allUnclassified","allAnnotation","diffDescription","descriptionTemplate","diff","ctx","paramCalculator","resolveParamCalculator","params","createDescription","descriptionParamCalculator","getDeclarationPathsForDiff","calculateDefaultDiffDescription","paths","DIFF_ACTION_TO_ACTION_MAP","descriptionTemplates","applyTemplateParams","templates","template","findTemplate","applyTempleParams","suitableTemplate","templateParams","matchResult","param","suitability","templateParam","placeholders","match","TEMPLATE_PARAM_ACTION","TEMPLATE_PARAM_PREPOSITION","TEMPLATE_PARAM_PROPERTY_NAME","TEMPLATE_PARAM_SCHEMA_PATH","TEMPLATE_PARAM_PLACE","TEMPLATE_PARAM_SCOPE","createDiff","_b","_c","_d","_e","_f","_g","classifierRule","mutableDiffCopy","classifier","changeType","type","reclassifyBreakingToRisky","error","createDiffEntry","diffFactory","PARENT_JUMP","strictResolveValueFromContext","resolveValueFromContext","optionalResolveValueFromContext","strict","fromObj","fromContext","countParentJump","pathItem","customUniqueItemsArrayMappingResolver","equalityFn","before","after","beforeArrayIndexes","afterArrayIndexes","beforeMatchedArrayIndexes","afterMatchedArrayIndexes","i","beforeItem","j","afterItem","deepEqualsUniqueItemsArrayMappingResolver","breakingIf","v","riskyIf","resolveSchemaDescriptionTemplates","details","DirectiveLocation$1","DirectiveLocation2","COMPARE_SCOPE_OUTPUT","COMPARE_SCOPE_ARGS","COMPARE_SCOPE_DIRECTIVE_USAGES","RUNTIME_DIRECTIVE_LOCATIONS","devAssert","condition","message","isObjectLike","invariant","LineRegExp","getLocation","source","position","lastLineStart","line","printLocation","location","printSourceLocation","sourceLocation","firstLineColumnOffset","body","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","lines","locationLine","subLineIndex","subLineColumnNum","subLines","printPrefixedLines","subLine","existingLines","_","padLen","prefix","toNormalizedOptions","args","firstArg","GraphQLError","rawArgs","_this$nodes","_nodeLocations$","_ref","nodes","positions","originalError","extensions","undefinedIfEmpty","nodeLocations","node","loc","pos","originalExtensions","output","formattedError","QueryDocumentKeys","kindValues","isNode","maybeNode","maybeKind","OperationTypeNode","OperationTypeNode2","DirectiveLocation","Kind","Kind2","isWhiteSpace","code","isDigit$1","isLetter","isNameStart","isNameContinue","printBlockString","options","escapedValue","isSingleLine","forceLeadingNewLine","hasTrailingTripleQuotes","hasTrailingQuote","hasTrailingSlash","forceTrailingNewline","printAsMultipleLines","skipLeadingNewLine","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","inspect","formatValue","seenValues","formatObjectValue","previouslySeenValues","isJSONable","jsonValue","formatArray","formatObject","object","entries","getObjectTag","len","remaining","items","tag","name","isProduction","instanceOf","constructor","_value$constructor","className","valueClassName","stringifiedValue","MAX_SUGGESTIONS","didYouMean","secondArg","subMessage","suggestionsArg","suggestions","x","selected","lastItem","identityFunc","keyMap","list","keyFn","item","keyValMap","valFn","mapValue","map","fn","naturalCompare","aStr","bStr","aIndex","bIndex","aChar","bChar","isDigit","aNum","DIGIT_0","bNum","DIGIT_9","suggestionList","input","optionsByDistance","lexicalDistance","LexicalDistance","threshold","option","distance","distanceDiff","stringToArray","optionLowerCase","tmp","aLength","bLength","rows","upRow","currentRow","smallestCell","cost","currentCell","doubleDiagonalCell","str","strLength","toObjMap","printString$1","escapedRegExp","escapedReplacer","escapeSequences","BREAK","visit","root","visitor","visitorKeys","enterLeaveMap","kind","getEnterLeaveForKind","stack","inArray","keys","edits","parent","ancestors","isLeaving","isEdited","editOffset","editKey","editValue","arrayKey","_enterLeaveMap$get","_enterLeaveMap$get2","visitFn","_node$kind","kindVisitor","print","ast","printDocASTReducer","MAX_LINE_LENGTH","join","varDefs","wrap","variable","defaultValue","directives","selections","block","alias","selectionSet","argsLine","indent","typeCondition","variableDefinitions","isBlockString","values","fields","description","operationTypes","operation","interfaces","hasMultilineItems","types","repeatable","locations","maybeArray","separator","_maybeArray$filter$jo","start","maybeString","end","_maybeArray$some","valueFromASTUntyped","valueNode","variables","field","assertName","assertEnumValueName","isType","isScalarType$1","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType$1","isNonNullType$1","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","ofType","isNullableType","resolveReadonlyArrayThunk","thunk","resolveObjMapThunk","config","_config$parseValue","_config$serialize","_config$parseLiteral","_config$extensionASTN","parseValue","_config$extensionASTN2","defineFieldMap","defineInterfaces","fieldsToFieldsConfig","_config$interfaces","fieldMap","isPlainObj","fieldConfig","fieldName","_fieldConfig$args","argsConfig","defineArguments","argName","argConfig","argsToArgsConfig","arg","_config$extensionASTN3","_config$extensionASTN4","defineTypes","_config$extensionASTN5","defineEnumValues","outputValue","enumValue2","enumValue","inputValue","valueStr","didYouMeanEnumValue","_variables","enumType","unknownValueStr","allNames","suggestedValues","typeName2","valueMap","valueName","valueConfig","_config$extensionASTN6","_config$isOneOf","defineInputFieldMap","GRAPHQL_MAX_INT","GRAPHQL_MIN_INT","coercedValue","serializeObject","num","GraphQLString","GraphQLBoolean","valueOfResult","GraphQLDirective","_config$isRepeatable","_config$args","DEFAULT_DEPRECATION_REASON","GRAPH_API_NODE_KIND_UNION","BUILT_IN_DIRECTIVE_SPECIFIED_BY","BUILT_IN_DIRECTIVE_SKIP","BUILT_IN_DIRECTIVE_INCLUDE","BUILT_IN_DIRECTIVE_DEPRECATED","BUILT_IN_DIRECTIVE_ONE_OF","BUILT_IN_DIRECTIVES","wrapBySingletonUnion","GRAPH_API_PROPERTY_ONE_OF","value2","combinerValues","wrap2","GRAPH_API_PROPERTY_DIRECTIVES","GRAPH_API_PROPERTY_TITLE","GRAPH_API_PROPERTY_TYPE","GRAPH_API_PROPERTY_KIND","setOrigins","copyOrigins","isRuntimeDirectiveLocations","isArray$1","graphApiSchemaAdapter","reference","newValue","valueContext","valueType","referenceType","valueKind","referenceKind","removeNotCorrectlySupportedInterfacesAdapter","complexTypeCompareResolver","beforeValue","afterValue","diffEntry2","diffEntry","titleBaseUniqueItemsArrayMappingResolver","one","another","isObject$1","nullableClassifier","scope","changedNullabilityValue","willHaveDefault","GRAPH_API_PROPERTY_DEFAULT","defaultClassifier","possibleDirectiveLocations","GRAPH_API_PROPERTY_LOCATIONS","argumentWasOptional","GRAPH_API_PROPERTY_NULLABLE","directiveUsageClassifier","mergeKey","directiveMetaClassifier","directiveLocations","GRAPH_API_PROPERTY_DEFINITION","oldDirectiveLocations","newDirectiveLocations","directiveArgumentsClassifier","directiveLocationClassifier","wasRuntime","willRuntime","simpleRule","classify","directivesUsagesRules","directiveDefinitionRules","baseRules","selfNamedBaseRules","typeUsageRules","typeDefinitionRules","methodRules","BREAKING_CHANGE_SEVERITY","CHANGE_SEVERITY_COLOR_MAP","CHANGE_SEVERITY_TOOLTIP_TITLE_MAP","CHANGE_SEVERITY_DESCRIPTION_MAP","CHANGE_SEVERITIES","MarkerTooltip","props","children","variant","variantToDescription","variantToTooltipTitle","variantToColor","disableHoverListener","category","categoryToTooltipTitle","jsx","Tooltip","MarkerTooltipContent","Box","tooltipContent","categoryTitle","jsxs","Divider","ChangesTooltip","memo","TOOLTIP_TITLE_BY_CATEGORY","CATEGORY_OPERATION","CATEGORY_PACKAGE"],"mappings":"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OAAO,OAAO,IAAI,EAC9C,SAAW,CAAC5R,EAAKE,CAAK,IAAK,OAAO,QAAQ4D,CAAG,EAC3C8N,EAAI5R,CAAG,EAAIE,EAEb,OAAO0R,CACT,CACA,SAASsC,GAAcH,EAAK,CAC1B,MAAO,IAAIA,EAAI,QAAQI,GAAeC,EAAe,CAAC,GACxD,CACA,MAAMD,GAAgB,gCACtB,SAASC,GAAgBL,EAAK,CAC5B,OAAOM,GAAgBN,EAAI,WAAW,CAAC,CAAC,CAC1C,CACA,MAAMM,GAAkB,CACtB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,MACA,MACA,MACA,UACA,MACA,MACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,GACA,GACA,MACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GAEA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GAEA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GAEA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,OACA,GACA,GACA,GAEA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GAEA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACF,EACMC,GAAQ,OAAO,OAAO,CAAA,CAAE,EAC9B,SAASC,GAAMC,EAAMC,EAASC,EAAcpH,GAAmB,CAC7D,MAAMqH,EAAgC,IAAI,IAC1C,UAAW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","x_google_ignoreList":[0,1]}