{"version":3,"file":"arrays-b0979955.js","sources":["../../packages/shared/src/utils/arrays.ts"],"sourcesContent":["/**\n * Copyright 2024-2025 NetCracker Technology Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO: Replace with standard `groupBy`/`groupByToMap`\n//  Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/groupBy, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/groupByToMap\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport function groupBy<T extends ReadonlyArray<any>>(\n  array: T,\n  key: string,\n): Record<string, T> {\n  return array.reduce(\n    (previousValue, currentValue) => {\n      (previousValue[currentValue[key]] = previousValue[currentValue[key]] ?? []).push(currentValue)\n      return previousValue\n    },\n    {},\n  )\n}\n\nexport function sortByProperty<T>(\n  array: ReadonlyArray<T>,\n  property: keyof T,\n): T[] {\n  const collator = new Intl.Collator(undefined, { numeric: true })\n  \n  return [...array].sort((a, b) => {\n    const aValue = a[property]\n    const bValue = b[property]\n\n    // Handle nullish values first (null/undefined values come last)\n    if (aValue === undefined || aValue === null) return 1\n    if (bValue === undefined || bValue === null) return -1\n\n    // Convert to strings and use Intl.Collator for proper sorting of all types\n    return collator.compare(String(aValue), String(bValue))\n  })\n}\n\nexport function deduplicate<T>(array: ReadonlyArray<T>): T[] {\n  return [...new Set(array)]\n}\n\nexport function deduplicateByKey<T, K extends keyof T>(array: ReadonlyArray<T>, key: K): T[] {\n  return Object.values(array.reduce<Record<string, T>>((previousValue, currentValue) => {\n    const index = currentValue[key] as string\n    if (previousValue[index] === undefined) {\n      previousValue[index] = currentValue\n    }\n    return previousValue\n  }, {}))\n}\n\nexport function isEmpty(array: unknown): boolean {\n  return array && Array.isArray(array) ? !array.length : true\n}\n\nexport function isNotEmpty(array: unknown): boolean {\n  return Boolean(array && Array.isArray(array) && array.length)\n}\n\nexport function isEmptyMap(map: unknown): boolean {\n  return Boolean(map && map instanceof Map && map.size === 0)\n}\n\nexport function isNotEmptyMap(map: unknown): boolean {\n  return Boolean(map && map instanceof Map && map.size !== 0)\n}\n\nexport function isNotEmptyRecord<T extends Record<string, unknown>>(record: T): boolean {\n  return Object.keys(record).length > 0\n}\n\nexport function isNotEmptySet(set: unknown): boolean {\n  return Boolean(set && set instanceof Set && set.size !== 0)\n}\n\nexport function insertIntoArrayByIndex<T>(array: T[], item: T, index: number): T[] {\n  array.splice(index, 0, item)\n  return array\n}\n\nexport function getLastItem<T>(array?: T[]): T | undefined {\n  return array?.length ? array[array?.length - 1] : undefined\n}\n"],"names":["isEmpty","array","isNotEmpty","isNotEmptyRecord","record"],"mappings":"AAkEO,SAASA,EAAQC,EAAyB,CAC/C,OAAOA,GAAS,MAAM,QAAQA,CAAK,EAAI,CAACA,EAAM,OAAS,EACzD,CAEO,SAASC,EAAWD,EAAyB,CAClD,MAAO,GAAQA,GAAS,MAAM,QAAQA,CAAK,GAAKA,EAAM,OACxD,CAUO,SAASE,EAAoDC,EAAoB,CACtF,OAAO,OAAO,KAAKA,CAAM,EAAE,OAAS,CACtC"}